---
layout: post
category: news
title: "Automatic Configuration Chains"
date: 2015-01-23 15:30
quote: There are more things in heaven and earth, Horatio, than are dreamt of in your philosophy.
quote_author: Shakespeare - "Hamlet"
product_slug: great_chain
licensing: false
cc_by_sa: false
comments: true
---
<p>In order to design an automatic discovery and configuration mechanism for popular 
small form factors like Arduino, LaunchPad, Raspberry Pi, and others,
we first need to decide on simple connection chain that can connect all the 
subsystems, one which is already included in each of these form factors.
We need to be able to describe the heirarchy of devices, and the connections between them, 
in order to understand the topology of our embedded system.
</p>
<!-- more -->
<p>
The problem reminds me somewhat of that faced by the early philosophers in trying to understand
their place in the hierarchy of the universe. Aristotle's 
<a href="http://en.wikipedia.org/wiki/History_of_Animals">History of Animals</a> 
classified organisms in relation to a linear "ladder of life", or <i>Scala Naturae</i>,
which allowed for an ordering of beings, from dirt at the bottom, to God at the very top,
with all creatures occupying rungs of the ascending ladder between.
The <a href="http://faculty.up.edu/asarnow/greatchainofbeing.htm">Great Chain of Being</a>
connected all things, as all things were linked together to form the universe in one solid, unbroken chain.
By the time of the Renaissance, the concept of <a href="http://faculty.up.edu/asarnow/greatchainofbeing.htm">Great Chain of Being</a> 
had become pervasive, used to justify the feudal system and the divine right of kings. 
Later still, this would influence poets such as Robert Blake to compose lines like, "As above, so below".
</p>
<p>
We also need to define a chain of physical entities, and the links that make up their interconnections.
In reality, we will need to define several, as some may be connected only by wireless linkages,
but for this introduction, we will discuss only the physically connected entities, such as an Ardunio Shield,
Beaglebone Cape, Raspberry Pi Plate, and the like.
</p>
<p>
The simplest and most ubiquitous interface found on all of these platforms is 
<a href="http://en.wikipedia.org/wiki/I%C2%B2C">I2C</a>, or the Inter-Integrated Circuit bus.
Also known as the "Two-Wire Bus" or TWB, <a href="http://en.wikipedia.org/wiki/I%C2%B2C">I2C</a>
is found on almost every embedded platform, and can be easily implemented with software 
<a href="http://en.wikipedia.org/wiki/Bit_banging">bit banging</a> on general purpose I/O pins (GPIO),
if a hardware interface block is not readily available. In addition, the 
<a href="http://www.mipi.org/">MIPI Alliance</a> is in the final stages of the ratification process for the new
<a href="http://mipi.org/specifications/i3c%E2%84%A0-sensor-specification">SenseWire/I3C Sensor Interface Specification</a>;
I3C defines a much higher performance interface, capable of supporting many more high speed sensors than
the original <a href="http://en.wikipedia.org/wiki/I%C2%B2C">I2C</a> bus specification.
</p>
<p>
<a href="http://en.wikipedia.org/wiki/I%C2%B2C">I2C</a> is a good choice for this purpose,
as it is both commonly available, and also supports the very low cost 
<a href="http://playground.arduino.cc/Code/I2CEEPROM">I2C EEPROMs</a> that we will
need for our configuration storage. An example implementation of this automatic configuration scheme
would resemble the diagram below : 
</p>
<p>
<img src="{{site.url.images}}/news/great_chain/i2c_mmi.png" alt="I2C Configuration Chain" title="I2C Configuration Chain"/>
</p>
<p>
Typical <a href="http://playground.arduino.cc/Code/I2CEEPROM">I2C EEPROMs</a> employ a three(3) bit hardware
selection mechanism, allowing up to eight(8) devices to share the same <a href="http://en.wikipedia.org/wiki/I%C2%B2C">I2C</a> bus.
In communicating with the <a href="http://playground.arduino.cc/Code/I2CEEPROM">I2C EEPROMs</a>, the first byte sent
is the control word, which serves to select which one of the eight(8) devices will respond to the read/write operation
on the shared <a href="http://en.wikipedia.org/wiki/I%C2%B2C">I2C</a> bus. 
</p>
<p>
<img src="{{site.url.images}}/news/great_chain/i2c_register.png" alt="I2C Register" title="I2C Register"/>
</p>
<p>
Using this addressing scheme, we can support up to eight(8) levels of devices in our stack, which should be
adequate for most purposes. The standard addressing for each level is shown in the table below :
<br>
<table border="2" spacing="2">
<tr>
<td>&nbsp; A2 &nbsp;</td>
<td>&nbsp; A1 &nbsp;</td>
<td>&nbsp; A0 &nbsp;</td>
<td>&nbsp; I2C Address &nbsp;</td>
<td>&nbsp; Device &nbsp;</td>
</tr>
<tr>
<td>&nbsp;&nbsp; 0 &nbsp;</td>
<td>&nbsp;&nbsp; 0 &nbsp;</td>
<td>&nbsp;&nbsp; 0 &nbsp;</td>
<td>&nbsp; &nbsp; &nbsp; 0x50 &nbsp;</td>
<td>&nbsp; Chassis (Power Supply) &nbsp;</td>
</tr>
<tr>
<td>&nbsp;&nbsp; 0 &nbsp;</td>
<td>&nbsp;&nbsp; 0 &nbsp;</td>
<td>&nbsp;&nbsp; 1 &nbsp;</td>
<td>&nbsp; &nbsp; &nbsp; 0x51 &nbsp;</td>
<td>&nbsp; Arduino &nbsp;</td>
</tr>
<tr>
<td>&nbsp;&nbsp; 0 &nbsp;</td>
<td>&nbsp;&nbsp; 1 &nbsp;</td>
<td>&nbsp;&nbsp; 0 &nbsp;</td>
<td>&nbsp; &nbsp; &nbsp; 0x52 &nbsp;</td>
<td>&nbsp; Shield #1 &nbsp;</td>
</tr>
<tr>
<td>&nbsp;&nbsp; 0 &nbsp;</td>
<td>&nbsp;&nbsp; 1 &nbsp;</td>
<td>&nbsp;&nbsp; 1 &nbsp;</td>
<td>&nbsp; &nbsp; &nbsp; 0x53 &nbsp;</td>
<td>&nbsp; Shield #2 &nbsp;</td>
</tr>
<tr>
<td>&nbsp;&nbsp; 1 &nbsp;</td>
<td>&nbsp;&nbsp; 0 &nbsp;</td>
<td>&nbsp;&nbsp; 0 &nbsp;</td>
<td>&nbsp; &nbsp; &nbsp; 0x54 &nbsp;</td>
<td>&nbsp; Shield #3 (Beaglebone Cape #1)&nbsp;</td>
</tr>
<tr>
<td>&nbsp;&nbsp; 1 &nbsp;</td>
<td>&nbsp;&nbsp; 0 &nbsp;</td>
<td>&nbsp;&nbsp; 1 &nbsp;</td>
<td>&nbsp; &nbsp; &nbsp; 0x55 &nbsp;</td>
<td>&nbsp; Shield #4 (Beaglebone Cape #2)&nbsp;</td>
</tr>
<tr>
<td>&nbsp;&nbsp; 1 &nbsp;</td>
<td>&nbsp;&nbsp; 1 &nbsp;</td>
<td>&nbsp;&nbsp; 0 &nbsp;</td>
<td>&nbsp; &nbsp; &nbsp; 0x56 &nbsp;</td>
<td>&nbsp; Shield #5 (Beaglebone Cape #3)&nbsp;</td>
</tr>
<tr>
<td>&nbsp;&nbsp; 1 &nbsp;</td>
<td>&nbsp;&nbsp; 1 &nbsp;</td>
<td>&nbsp;&nbsp; 1 &nbsp;</td>
<td>&nbsp; &nbsp; &nbsp; 0x57 &nbsp;</td>
<td>&nbsp; Shield #6 (Beaglebone Cape #4)&nbsp;</td>
</tr>
</table>
</p>
<p>
You'll notice that the Arduino (or Launchpad, etc.) is not at the 
very bottom of the stack, as there may be a chassis or other lower level that
the stack is mounted within, in order to provide battery or solar power to the system.
We may need to be able to interogate that level to inquire how much power is available,
or inquire about other parameters. In later articles, I'll outline some other uses
for the lowest level, such as instrumentation, testing, and monitoring of the system.
</p>
<p>
So, what about more than eight(8) levels you might be asking? What then?
Well, the <a href="http://en.wikipedia.org/wiki/I%C2%B2C">I2C</a> bus has
some physical loading limitations, that have to do with the larger bus capacitances
that result when you extend the bus too far, or add too many loads(devices). 
In practice, there may need to be 
<a href="http://en.wikipedia.org/wiki/I%C2%B2C">I2C</a> bus buffers, repeaters,
hubs, or multiplexors employed to keep each segment of the 
<a href="http://en.wikipedia.org/wiki/I%C2%B2C">I2C</a> bus within specified loading limits.
However, the addressing scheme above would apply to each separate segment of a larger
system, although you may need to address a multiplexor or hub first to select a
particular segment to read or write.
</p>
<p>
You might also notice that the Beaglebone "Capes" (the name for their expansion boards)
are limited to four(4) "Capes", this is a specific limitation of the Beaglebone.
</p>
<p>
The next step is to define the data structure within each of the 
<a href="http://playground.arduino.cc/Code/I2CEEPROM">I2C EEPROMs</a> shown,
and how that data structure defines the components and topology of the overall system.
The next article will cover currently available data structures like the DeviceTree
and IPMI formats. 
</p>

