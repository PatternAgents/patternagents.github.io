---
layout: post
category: news
title: "The BLOB - Binary Level OBjects"
date: 2015-01-25 09:30
quote: Obstacles are those frightful things you see when you take your eyes off your goal.
quote_author: Henry Ford
product_slug: theblob
licensing: false
cc_by_sa: false
comments: true
---
<p>There are a number of different metadata formats for containing low-level configuration information,
some of them are in plain ASCII text, and others are in various encoded binary formats. The encoded binary formats, or 
Binary Level OBjects, are commonly referred to as 
<a href="#BLOB">"BLOBs"</a>. 
In this article, I will discuss how some of those formats are being used in existing products.
</p>
<!-- more -->
<p>
<img class="illo" src="/img/news/theblob/Blob-Town.png" width="320" height="300" alt="Blob Town" title="Blob Town"/>
Let's start with the <a href="https://www.devicetree.org/Device_Tree_Usage">DeviceTree</a> format, 
which is often utilized in describing the hardware of higher end platforms to the Linux Kernal. 
The <a href="https://www.devicetree.org/Device_Tree_Usage">DeviceTree</a> definition starts with a
<a href="https://lxr.free-electrons.com/source/arch/arm/boot/dts/imx28-evk.dts">DeviceTree Specification File</a>
also known as a .dts file. The <a href="https://lxr.free-electrons.com/source/arch/arm/boot/dts/imx28-evk.dts">DeviceTree Specification File</a>
is a human readable definiton of everything about the embedded platform, including CPU type, amount of memory, internal buses (AHB/APB/etc.),
and all the relevent interfaces, like USB, UART, PCI, SPI/MMC, Ethernet MAC, GPIO pins, Pin Multiplexing, and more. 
It is a very complete specification of the underlying hardware platform. 
The <a href="https://lxr.free-electrons.com/source/arch/arm/boot/dts/imx28-evk.dts">DeviceTree Specification File</a>
is then run through the <a href="https://www.devicetree.org/Device_Tree_Compiler">DeviceTree Compiler</a> which produces the 
<a href="https://www.devicetree.org/Device_Tree_Compiler">DeviceTree Binary Object</a> (i.e. The Blob) which is also known as the ".dtb" file.
The <a href="https://www.devicetree.org/Device_Tree_Compiler">DeviceTree Binary Object</a> (i.e. The Blob of the "Flattened Device Tree") is
typically read in as part of the operating system booting procedure, and used to determine what device drivers are loaded into the operating system.
I'll go into how this process works in much more detail in a later article, but that's the basic idea of a compiled Device Tree.   
</p>
<p>
So how does this process relate to the <a href="https://www.intel.com/content/www/us/en/servers/ipmi/information-storage-definition-rev-1-2.html">IPMI FRU</a> : (Intelligent Peripheral Management Interface - Field Replaceable Unit) data structure definition for add-on boards,
and the <a href="https://standards.ieee.org/findstds/standard/1451.4-2004.html">TEDS</a> (Transducer Electronic Data Sheet)
data structure definition for attached Sensor devices? The following diagram depicts their relationship :
</p>
<p>
<img src="/img/news/theblob/blobs-diagram.png" alt="Embedded Blobs" title="Embedded Blobs"/>
</p>
<p>
So, to put this all together in a more simple explaination :
<ul>
<li>During the Main Board boot-up sequence, the <a href="https://www.devicetree.org/Device_Tree_Usage">Device Tree</a> BLOB is
    parsed to determine all of the hardware interfaces contained on the Main Board.</li>
<li>After the initial Main Board boot-up sequence, the 
    <a href="https://www.intel.com/content/www/us/en/servers/ipmi/information-storage-definition-rev-1-2.html">IPMI FRU</a> is
    parsed to determine the make and model of the attached Expansion Board, which identifies the attached Sensors.
</li>
<li>Then the <a href="https://standards.ieee.org/findstds/standard/1451.4-2004.html">TEDS</a> BLOBs are each  
    parsed to determine the parameters of the attached Sensors.
</li>
<li>Finally, the Operating System (Linux/Android) has all the information necessary to read and interpret the attached Sensors.</li>
</ul>
</p>
<p>
That is a very quick overview of what is a highly complex process for automatic discovery and configuration, 
based on currently used standards. The upshot of all of this is that at least three (3) separate and
distinct parsers (namely DeviceTree, IPMI FRU, and TEDS, respectively) are required to put all of this together. 
For an embedded Linux system, such as a Xilinx Zynq based system, or an ARM A8/A9 class system, 
we are talking about a fairly large amount of code to implement each of the different parsers 
required to extract the necessary information. Do we really need three (3) or different ways (or more...)
to encode similar data like this? Isn't there a more uniform way to accomplish this? 
</p>
<p>
As one of my engineering buddies used to say, 
<i>"Standards are great, and there are so many incompatible ones to choose from!"</i>
Clearly this kind of approach is going to be more difficult on resource constrained small systems,
such as the Arduino, rfDuino, and TI LaunchPad. So, what can we do to improve the current state of the art here?
</p>
<p>
In our next segment, we'll discuss several of the evolving standards for Sensor Parameters
that are being used in Sensor Hub and Sensor Fusion implementations, and what that means
for developing an all encompassing method of automatic discovery and configuration
on small form factor embedded platforms.
</p>
<p>
<table border="0">
<tr>
<td>
And finally, for your viewing pleasure, the original trailer for the 1958 feature "The Blob",
starring a very young Steve McQueen. I still remember the first time I saw this movie, in
a Drive-In Theater with my parents and family, in a
<a href="https://www.youtube.com/watch?v=eOm5P1AkUi4">Studebaker Wagonaire</a>.
</td>
<td>
  <div class="container.four-three">
	  <iframe width="427" height="255" src="//www.youtube.com/embed/TdUsyXQ8Wrs?HD=1;rel=0;showinfo=0;controls=0" frameborder="0" allowfullscreen></iframe>
  </div>
</td>
</tr>
</table>
</p>
<p>
&nbsp;
</p>
<p>
<a name="#BLOB"></a>
<a href="https://en.wikipedia.org/wiki/Binary_large_object">Wikipedia</a> attributes the programming reference of "BLOBs"as a
<a href="https://en.wikipedia.org/wiki/Backronym"><i>backronym</i></a> to Terry McKiever, a marketing person for Apollo;
who felt that it needed to be an acronym and invented the "Basic Large Object", which became widely used as "Binary Large Object".
Since what I'm trying to implement are very small objects, I prefer the acronym, "Binary Level OBject".
</p>
<p>
</p>


