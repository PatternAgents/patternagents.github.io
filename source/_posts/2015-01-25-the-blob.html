---
layout: post
category: news
title: "The BLOB - Binary Level OBjects"
date: 2015-01-25 09:30
quote: Obstacles are those frightful things you see when you take your eyes off your goal.
quote_author: Henry Ford
product_slug: theblob
licensing: false
cc_by_sa: false
comments: true
---
<p>There are a number of different metadata formats for containing low-level configuration information,
some of them are in plain ASCII text, and others are in various encoded binary formats. The encoded binary formats, or 
Binary Level OBjects, are commonly referred to as  "BLOBs". In this article I'll cover how some of those formats
are implemented and applied.
</p>
<!-- more -->
<p>
<img class="illo" src="{{site.url.images}}/news/theblob/Blob-Town.png" width="320" height="300" alt="Blob Town" title="Blob Town"/>
Let's start with the <a href="http://www.devicetree.org/Device_Tree_Usage">DeviceTree</a> format, 
which is often utilized in describing the hardware of higher end platforms to the Linux Kernal. 
The <a href="http://www.devicetree.org/Device_Tree_Usage">DeviceTree</a> definition starts with a
<a href="http://lxr.free-electrons.com/source/arch/arm/boot/dts/imx28-evk.dts">DeviceTree Specification File</a>
also know as a .dts file. The <a href="http://lxr.free-electrons.com/source/arch/arm/boot/dts/imx28-evk.dts">DeviceTree Specification File</a>
is a human readable definiton of everything about the embedded platform, including CPU type, amount of memory, internal buses (AHB/APB/etc.),
and all the relevent interfaces, like USB, UART, PCI, SPI/MMC, Ethernet MAC, GPIO pins, Pin Multiplexing, and more. 
It is a very complete specification of the underlying hardware platform. 
The <a href="http://lxr.free-electrons.com/source/arch/arm/boot/dts/imx28-evk.dts">DeviceTree Specification File</a>
is then run through the <a href="http://www.devicetree.org/Device_Tree_Compiler">DeviceTree Compiler</a> which produces the 
<a href="http://www.devicetree.org/Device_Tree_Compiler">DeviceTree Binary Object</a> (i.e. The Blob) also known as the .dtb file.
The definition of the <a href="http://www.devicetree.org/Device_Tree_Usage">DeviceTree</a> specification file and
subsequent bootloading of a Linux distribution on "Bare-Metal" hardware is usually only attempted by those of "Linux Guru" stature,
or the manufacturer of the System-on-Chip device architecture.
</p>
<p>
So how does this process relate to the <a href="http://www.intel.com/content/www/us/en/servers/ipmi/information-storage-definition-rev-1-2.html">IPMI FRU</a> : (Intelligent Peripheral Management Interface - Field Replaceable Unit) definiton for add-on boards,
and the <a href="http://standards.ieee.org/findstds/standard/1451.4-2004.html">TEDS</a> (Transducer Electronic Data Sheet)
for attached Sensor devices? The following diagram depicts their relationship :
</p>
<p>
<img src="{{site.url.images}}/news/theblob/blobs-diagram.png" alt="Embedded Blobs" title="Embedded Blobs"/>
</p>
<p>
So, to try and put this all together in a more simple explaination :
<ul>
<li>During the Main Board boot-up sequence, the <a href="http://www.devicetree.org/Device_Tree_Usage">DeviceTree</a> BLOB is
    parsed to determine all the hardware interfaces contained on the Main Board.</li>
<li>After the initial Main Board boot-up sequence, the 
    <a href="http://www.intel.com/content/www/us/en/servers/ipmi/information-storage-definition-rev-1-2.html">IPMI FRU</a> is
    parsed to determine the make and model of the attached Expansion Board, which identifies the attached Sensors.
</li>
<li>Then the <a href="http://standards.ieee.org/findstds/standard/1451.4-2004.html">TEDS</a> BLOBs are each  
    parsed to determine the parameters of the attached Sensors.
</li>
<li>Finally, the Operating System (Linux/Android) has all the information necessary to read and interpret the attached Sensors.</li>
</ul>
</p>
<p>
That is a very quick overview of what is a highly complex process for automatic discovery and configuration, 
based on currently used standards. The upshot of all of this is that at least three (3) separate and
distinct parsers (namely DeviceTree, IPMI FRU, and TEDS, respectively) are required to put all of this together. 
For an embedded Linux system, such as a Xilinx Zynq based system, or an ARM A8/A9 class system, 
we are taking about a fairly large amount of code to implement each of the different parsers 
required to extract the necessary information.
</p>
<p>
As one of my engineering buddies used to say, 
<i>"Standards are great, and there are so many incompatible ones to choose from!"</i>
Clearly this kind of approach is not going to work for resource constrained small systems,
such as the Arduino, and is barely acheivable on medium sized platforms like the Raspberry Pi.
So, what can we do to improve the current state of the art here?
</p>
<p>
In our next segment, we'll discuss several of the evolving standards for Sensor Parameters
that are being used in Sensor Hub and Sensor Fusion implementations, and what that means
for developing an all encompassing method for automatic discovery and configuration
on small form factor embedded platforms.
</p>
<p>
<table border="0">
<tr>
<td>
And finally, for your viewing pleasure, the original trailer for the 1958 feature "The Blob",
starring a very young Steve McQueen. I still remember the first time I saw this movie, in
a Drive-In Theater with my family, in an old Studbaker Station Wagon.
</td>
<td>
  <div class="container.four-three">
	  <iframe width="427" height="255" src="//www.youtube.com/embed/TdUsyXQ8Wrs?HD=1;rel=0;showinfo=0;controls=0" frameborder="0" allowfullscreen></iframe>
  </div>
</td>
</tr>
</table>
</p>


<p>

</p>

