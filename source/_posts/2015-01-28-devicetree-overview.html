---
layout: post
category: news
title: "Device Tree Overview"
date: 2015-01-28 09:30
quote: In nature, nothing is perfect and everything is perfect. Trees can be contorted, bent in weird ways, and they're still beautiful.
quote_author: "Alice Walker"
product_slug: devicetree
licensing: false
cc_by_sa: false
comments: true
---
<p>Recently, I've been talking about the <a href="http://www.devicetree.org/">Device Tree</a> format,
which is becoming widely used for automatically configuring the hardware of embedded computing platforms like the Beaglebone Black,
Xilinx Zynq, Altera Arria, and many other System-on-Chip (SOC) devices. The <a href="http://www.devicetree.org/">Device Tree</a> 
is read during the computing platform boot up sequence, and it describes all the hardware of the embedded computing platform. 
It contains descriptions of all the platform parameters, like how much memory, what kind of interfaces, 
how many peripherals, etc. are expected to be present in that make and model of platform.
In this article, I'll introduce more of the details of the <a href="http://www.devicetree.org/">Device Tree</a> format, 
and how it is being used on current embedded computing platforms.  
</p>
<!-- more -->
<p>
<h2>What is the Device Tree?</h2>
The <a href="http://www.devicetree.org/">Device Tree</a> is a data structure 
for describing the heirarchy of hardware subsystems within a computing platform,  or an add-on peripheral to that platform. 
It can be used to automatically select and configure the device drivers for that computing platform. 
</p>
<p>
<h2>Why Device Tree?</h2>
<img class="illo" src="{{site.url.images}}/news/devicetree/device-tree-nodes.png" alt="Example Device Tree Nodes" title="Example Device Tree Nodes"/>
As many new and different System-on-Chip (SOC) based embedded computing platforms started appearing a few years ago, 
it became increasingly difficult to support all the various operating system configurations required
for Linux, IOS, Windows, and others.
</p>
<p>
Prior to the adoption of the <a href="http://www.devicetree.org/">Device Tree</a> format,
this platform information was contained in what is known as the 
<a href="http://en.wikipedia.org/wiki/Board_support_package">Board Support Package (BSP)</a>,
a group of files provided by the manufacturer of that particular board.
Each new operating system version would need to include the hardware configuration information
from the <a href="http://en.wikipedia.org/wiki/Board_support_package">Board Support Package (BSP)</a>
in order to be able to run on that particular board. This quickly because a bottleneck in the process
of supporting new computing platforms that had only minor variations, so Linus Torvalds and others needed to 
<a href="http://article.gmane.org/gmane.linux.ports.arm.omap/55060">push back</a>, 
and come up with a more dynamic method of describing the hardware of the computing platform. 
</p>
<p>
The <a href="http://www.devicetree.org/">Device Tree</a> format was adopted to serve as the container format
for hardware configuration information required during the boot process, however a way was still needed to
modify the system after the boot up process, and to support expansion boards and subsystems.
Pantelis Antoniu, Grant Likely, and others have outlined a solution that
allows for <a href="https://lkml.org/lkml/2013/1/7/366">Device Tree Overlays</a>, and an 
<a href="https://lkml.org/lkml/2013/1/7/366">expansion board (Cape) manager</a>
to modify the <a href="http://www.devicetree.org/">Device Tree</a> from user-space, during run-time.
This allows users to load and unload hardware peripherals and drivers as needed.
The transition away from solely using <a href="http://en.wikipedia.org/wiki/Board_support_package">Board Support Package (BSP)</a> 
files to the <a href="http://www.devicetree.org/">Device Tree</a> format is ongoing,
and <a href="http://elinux.org/images/5/5c/ELCE2013_-_DT_War.pdf">not without it's share of problems</a>.
</p>
<p>
<h2>Embedded Device Trees</h2>
So, what is an embedded device tree, and how do we describe it?
Let's look at a common example, say the  <a href="http://beagleboard.org/BLACK">BeagleBone Black</a>, which uses an OMAP3 System-on-Chip from Texas Instruments.
A very (very) simplified example, including just the CPU and it's main memory, would look something like this :
</p>
<p>
<table>
<tr>
<td>&nbsp;</td>
<td>
<img src="{{site.url.images}}/news/sff/beagleboneblack.png" alt="BeagleBone Black" title="BeagleBone Black"/>
</td>
<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>
<img src="{{site.url.images}}/news/devicetree/device-tree-bbb.png" alt="BeagleBone Black Device Tree" title="BeagleBone Black Device Tree"/>
</td>
<td>&nbsp;</td>
</tr>
</table>
</p>
<p>
The corresponding <a href="http://www.devicetree.org/">Device Tree Source (.dts)</a> file for the above would look something like :
{% highlight c linenos %}
{
        model      = "TI AM335x BeagleBone Black";
        compatible = "ti,beaglebone-black",
                     "ti,am335x-boneblack",
                     "ti,am335x-bone",
                     "ti,am33xx";
        cpus {
                cpu@0 {
                       cpu0-supply = <&dcdc2_reg>;	
                };	
        };	
        memory {	
                device_type = "memory";
                reg = <0x80000000 0x10000000>; /* 256 MB */	
        };
};
{% endhighlight %}
</p>
<p>
As we can see from the above <a href="http://www.devicetree.org/">Device Tree Source (.dts)</a> example, we have defined the following :
<ul>
<li>model &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : defines the model name of this board</li>
<li>compatible : defines the manufacturer & model compatibility list</li>
<li>cpus &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;: defines a single cpu with a node name of "cpu", and what power supply it uses</li>
<li>memory &nbsp; &nbsp; &nbsp; : defines 256 MegaBytes of main memory on this model, and it's address range</li>
</ul>
Of course, the actual Device Tree Source (.dts) file, in this case, the 
<a href="http://git.ti.com/wilink8-wlan/wilink8-wlan-ti-linux-kernel/blobs/9bf81aa9157a358fa53ab015e01c08bc68788709/arch/arm/boot/dts/am335x-bone-common.dtsi">am335x-bone-common.dtsi</a> include file has much more detail, but I'll build it up the concepts gradually using simplified snippets.
</p>
<p>
Next we'll add some input/output to the Device Tree Source (.dts) file, and we'll start with a simple I2C controller
in order to create a tiny, but useful little computing platform description : 
{% highlight c linenos %}
{
        model      = "TI AM335x BeagleBone Black";
        compatible = "ti,beaglebone-black",
                     "ti,am335x-boneblack",
                     "ti,am335x-bone",
                     "ti,am33xx";
        cpus {
                cpu@0 {
                       cpu0-supply = <&dcdc2_reg>;	
                };	
        };	
        memory {	
                device_type = "memory";
                reg = <0x80000000 0x10000000>; /* 256 MB */	
        };
        am33xx_pinmux: pinmux@44e10800 {
		pinctrl-names = "default";
		pinctrl-0 = <&clkout2_pin>;
		i2c0_pins: pinmux_i2c0_pins {
			pinctrl-single,pins = <
                                /* i2c0_sda.i2c0_sda pin */
				0x188 (PIN_INPUT_PULLUP | MUX_MODE0)
				/* i2c0_scl.i2c0_scl */
				0x18c (PIN_INPUT_PULLUP | MUX_MODE0)
			>;
		};
        };
        ocp {
		i2c0: i2c@44e0b000 {
			pinctrl-names = "default";
			pinctrl-0 = <&i2c0_pins>;
			status = "okay";
			clock-frequency = <400000>;
			tps: tps@24 {
				reg = <0x24>;
			};
        };
};
{% endhighlight %}
</p>
<p>
The first thing we added above is the I/O Pin Multiplexing defintions, as most modern System-on-Chip (SoC) devices have several
functions available per pin for application flexibility. We need to define what pins are going to be used to connect the 
<a href="http://en.wikipedia.org/wiki/I%C2%B2C">I2C</a> controller to the outside world.
<ul>
<li>am33xx_pinmux: the label for the pin multiplexing control registers (pinmux) at address 0x44e10800 </li>
<li>i2c0_pins : the label for the pins assigned to the <a href="http://en.wikipedia.org/wiki/I%C2%B2C">I2C</a> Controller at offsets 0x188 and 0x18C</li>
</ul>
</p>
<p>
The next section defines the <a href="http://en.wikipedia.org/wiki/I%C2%B2C">I2C</a> controller itself, which is located on the 
<a href="http://en.wikipedia.org/wiki/Open_Core_Protocol">OCP bus (Open Core Protocol)</a>
which is the name for one of internal bus connections in the System-on-Chip (SoC):
<ul>
<li>i2c0: the label for the first I2C controller block at address 0x44e0b000 </li>
<li>status: we expect the I2C controller block status to be operational</li>
<li>clock-frequency: the I2C bus is running at 400Khz</li>
</ul>
<p>
And finally, we describe a sub-node of the <a href="http://en.wikipedia.org/wiki/I%C2%B2C">I2C</a> 
controller (i.e. an attached I2C device), called "tps":
<li>tps: the label for the power supply controller chip</li>
<li>reg: the I2C bus address for the "tps" device is 0x24 
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (this is a "subnode" or indirect address)</li>
</ul>
</p>
<p>
Alright, now we need to define the "tps" node to make this a more complete <a href="http://www.devicetree.org/">Device Tree Source (.dts)</a> file,
which allows me to introduce the concept of power supply descriptions. It is really useful to know how much power that the power supplies on
a board are capable of providing, and what additional power that expansion devices or add-on boards will require. 
That will allow us to indicate an error if an expansion device requires more power than we are capable of providing.

{% highlight c linenos %}
/include/ "tps65217.dtsi"
&tps {
	regulators {
		dcdc1_reg: regulator@0 {
			regulator-always-on;
		};
		dcdc2_reg: regulator@1 {
			regulator-name = "vdd_mpu";
			regulator-min-microvolt = <925000>;
			regulator-max-microvolt = <1325000>;
			regulator-boot-on;
			regulator-always-on;
		};
		dcdc3_reg: regulator@2 {
			regulator-name = "vdd_core";
			regulator-min-microvolt = <925000>;
			regulator-max-microvolt = <1150000>;
			regulator-boot-on;
			regulator-always-on;
		};
		ldo1_reg: regulator@3 {
			regulator-always-on;
		};

	};
};
{% endhighlight %}
</p>
<p>
In the above example, you'll start to see the use of Device Tree Source Include files (.dtsi),
which allow us to include subnode definitions by model name, for building heirarchically.
You'll also notice the defintion of the "dcdc2_reg" label here, which was used in out first
example to define the power supply for the cpu. A few of the parameters worth mentioning:
<ul>
<li>regulator-min-microvolt: how we define the min/max range of the power supplies</li>
<li>regulator-boot-on: this regulator is on during booting</li>
<li>regulator-always-on: this regulator is expected to be always powered up</li>
</ul>
<p>
<h2>Installing the Device Tree Compiler</h2>
On a typical Linux system distribution, you can install the Device Tree compiler using :

{% highlight c %}
sudo apt-get install -y device-tree-compiler
{% endhighlight %}

Then check your installation, by asking for the DTC version :
{% highlight c %}
moxon@fs:~$ dtc -v
Version: DTC 1.3.0
moxon@fs:~$
{% endhighlight %}

If you are looking for a specific how-to guide for BeagleBone, Raspberry Pi, Xixlinx, Altera, etc,
please see the References section at the end of this article for a complete listing. A number of people
in the community have already written some excellent guides for specific platforms. 
</p>
<p>
<h2>Using the Device Tree Compiler</h2>
The Device Tree Compiler is a simple command line tool that is used to read 
<a href="http://www.devicetree.org/">Device Tree Source (.dts)</a> files, and 
generate a Flattened Device Tree Binary Object file (.dtb), also known as the
"Device Tree BLOB".

{% highlight c %}
moxon@fs:~$ dtc -O dtb -o outputBLOB.dtb -b 0 inputSOURCE.dts
{% endhighlight %}
Pretty simple really, the Device Tree Compiler reads the input file named "inputSOURCE.dts",
and generates the output file named "outputBLOB.dtb". The output file can then be loaded into
flash or EEPROM for use during the boot up sequence.
</p>
<p>
<p>
<h2>Flattened Device Tree Binary Objects (.dtb)</h2>
So what does the output of the Device Tree Compiler look like?
If you want the gory details(including the address alignment requirements), they are described in 
<a href="https://www.power.org/wp-content/uploads/2012/06/Power_ePAPR_APPROVED_v1.1.pdf">Chapter 8 of the ePAPR specification</a>,
but here's a quick overview : 
</p>
<p>
<img src="{{site.url.images}}/news/devicetree/device-tree-fdt.png" alt="Flattened Device Tree" title="Flattened Device Tree"/>
</p>
<p>
And the Flattened Device Tree Binary Header Structure (fdt_header) looks like this :
</p>
<p>
<img src="{{site.url.images}}/news/devicetree/device-tree-fdt-header.png" alt="Flattened Device Tree Header" title="Flattened Device Tree Header"/>
</p>
<p>
After the Flattened Device Tree Binary Header Structure, comes the memory reservation block, the structure block, and the strings block, respectively.
So the Flattened Device Tree Binary format is not that complicated to understand, and the main "action" occurs by parsing the "structure" block,
which holds the node relationships (i.e. the graph of the tree). The structure block is a list of nodes, separated by the following <i>tokens</i>
to give the tree it's structure :
<ul>
<li>0x00000001 : FDT_BEGIN_NODE : Starts a node description, with node name and address as strings</li>
<li>0x00000002 : FDT_END_NODE &nbsp; &nbsp; : Ends a node description</li>
<li>0x00000003 : FDT_PROP &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : Starts a node property, followed by a node property structure</li>
<li>0x00000003 : FDT_NOP &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : No Operation, used as a placeholder and alignment filler</li>
<li>0x00000003 : FDT_END &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : Ends the structure block, only one per Device Tree.</li>
</ul>
At the end of the Flattened Device Tree Binary Object is the "Strings Block", containing all the property name strings used in the tree
concatenated together. The "Structure Block" refers to the strings within the "String Block" using an offset from the start address of
the "Strings Block". If you want to take a look at a FDT parser,  then check out the
<a href="https://packages.debian.org/wheezy/libfdt-dev">libfdt library</a> for handling FDT (BLOB) objects.
</p>
<p>
In the next article, I'll cover Device Tree Overlays, the new mechanism for describing the hardware
of add-on boards like BeagleBone "Capes", or Raspberry Pi "Plates".
</p>
<p>   
<h2>References, Footnotes, and more Device Tree information...</h2>
<ol>
<li><a href="http://events.linuxfoundation.org/sites/events/files/slides/petazzoni-device-tree-dummies.pdf">Device Tree for Dummies - Thomas Petroni</a></li>
<li><a href="https://learn.adafruit.com/introduction-to-the-beaglebone-black-device-tree">BeagleBlack Device Tree Tutorial - Adafruit</a></li>
<li><a href="http://xillybus.com/tutorials/device-tree-zynq-1">Xilinx Device Tree Tutorial - Xillybus</a></li>
<li><a href="http://xillybus.com/tutorials/device-tree-altera-soc-cyclone">Altera Device Tree Tutorial - Xillybus</a></li>
<li><a href="https://blueprints.launchpad.net/ubuntu/+spec/mobile-lucid-arm-device-tree-support">ARM Device Tree Support - Ubuntu</a></li>
<li><a href="http://www.alterawiki.com/wiki/Sopc2dts">Altera Device Tree Support - Altera</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/devicetree/bindings/">Index of Device Tree Bindings - kernal.org</a></li>
<li><a href="http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/plain/Documentation/devicetree/bindings/graph.txt">Device Tree Graphing - kernal.org</a></li>
<li><a href="https://packages.debian.org/wheezy/libfdt-dev">libfdt - manipulating FDT Blobs - David Gibson</a></li>
<li><a href="http://www.informit.com/articles/article.aspx?p=1647051&seqNum=5">Linux Bootloaders - informit.com</a></li>
<li><a href="http://haifux.org/lectures/288/haifux-devicetree.pdf">Device Tree PnP - Eli Billauer</a></li>
<li><a href="https://lkml.org/lkml/2013/1/7/366">Device Tree Overlay Manager - Pantelis Antoniou</a></li>
<li><a href="https://lkml.org/lkml/2012/11/5/615">Device Tree Overlay Proposal - Grant Likely</a></li>
<li><a href="https://github.com/cdsteinkuehler/beaglebone-universal-io">BeagleBlack Univeral I/O - cdsteinkuehler</a></li>
<li><a href="http://kilobaser.com/blog/2014-07-28-beaglebone-black-devicetreeoverlay-generator#dtogenerator">BeagleBlack Device Tree Overlay Generator - Kilobaser</a></li>
<li><a href="http://derekmolloy.ie/gpios-on-the-beaglebone-black-using-device-tree-overlays/">GPIOs on the Beaglebone Black using the Device Tree Overlays- derek molloy</a></li>
<li><a href="http://elinux.org/images/f/f2/Supporting_200_Different_Expansionboards_The_Broken_Promise_of_Devicetree.pdf">Supporting 200 Different Expansion Boards -  elinux.org</a></li>
<li><a href="http://events.linuxfoundation.org/sites/events/files/slides/presentation_3.pdf">DT, The Disaster so Far - Mark Rutland</a></li>
<li><a href="http://elinux.org/images/5/5c/ELCE2013_-_DT_War.pdf">Board File to Device Tree Migration - Pantelis Antoniou</a></li>
</ol>
</p>

