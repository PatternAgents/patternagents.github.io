---
layout: post
category: news
title: "Device Tree Overview"
date: 2015-01-28 09:30
quote: In nature, nothing is perfect and everything is perfect. Trees can be contorted, bent in weird ways, and they're still beautiful.
quote_author: "Alice Walker"
product_slug: devicetree
licensing: false
cc_by_sa: false
comments: true
---
<p>In the last few articles, I've been talking about the <a href="http://www.devicetree.org/">DeviceTree</a> format,
which is becoming widely used for automatically configuring the hardware of embedded computing platforms like the Beaglebone Black,
Xilinx Zynq, Altera Arria, and many other System-on-Chip (SOC) devices. The <a href="http://www.devicetree.org/">DeviceTree</a> 
is read during the computing platform boot up sequence, and it describes all the hardware of the embedded computing platform. 
It contains descriptions of all the platform parameters, like how much memory, what kind of interfaces, 
how many peripherals, etc. are expected to be present in that make and model of platform.
In this article, I'll introduce more of the details of the <a href="http://www.devicetree.org/">DeviceTree</a> format, 
and how it is being used on current embedded computing platforms.  
</p>
<!-- more -->
<p>
<h2>What is the Device Tree?</h2>
The <a href="http://www.devicetree.org/">DeviceTree</a> is a data structure 
for describing the heirarchy of hardware subsystems within a computing platform,  or an add-on peripheral to that platform. 
It can be used to automatically select and configure the device drivers for that computing platform. 
</p>
<p>
<h2>Why Device Tree?</h2>
<img class="illo" src="{{site.url.images}}/news/devicetree/device-tree-nodes.png" alt="Example Device Tree Nodes" title="Example Device Tree Nodes"/>
As many new and different System-on-Chip (SOC) based embedded computing platforms started appearing a few years ago, 
it became increasingly difficult to support all the various operating system configurations required
for Linux, IOS, Windows, and others.
</p>
<p>
Prior to the adoption of the <a href="http://www.devicetree.org/">Device Tree</a> format,
this platform information was contained in what is known as the 
<a href="http://en.wikipedia.org/wiki/Board_support_package">Board Support Package (BSP)</a>,
a group of files provided by the manufacturer of that particular board.
Each new operating system version would need to include the hardware configuration information
from the <a href="http://en.wikipedia.org/wiki/Board_support_package">Board Support Package (BSP)</a>
in order to be able to run on that particular board. This quickly because a bottleneck in the process
of supporting new computing platforms that had only minor variations, so Linus Torvalds and others needed to 
<a href="http://article.gmane.org/gmane.linux.ports.arm.omap/55060">push back</a>, 
and come up with a more dynamic method of describing the hardware of the computing platform. 
</p>
<p>
The <a href="http://www.devicetree.org/">Device Tree</a> format was adopted to serve as the container format
for hardware configuration information required during the boot process, however a way was still needed to
modify the system after boot up. Pantelis Antoniu, Grant Likely, and others have outlined a solution that
allows for <a href="https://lkml.org/lkml/2013/1/7/366">Device Tree Overlays</a>, and an 
<a href="https://lkml.org/lkml/2013/1/7/366">expansion board (Cape) manager</a>
to modify the <a href="http://www.devicetree.org/">Device Tree</a> from user-space, during run-time.
This allows users to load and unload hardware peripherals and drivers as needed.
The transition away from solely using <a href="http://en.wikipedia.org/wiki/Board_support_package">Board Support Package (BSP)</a> 
files to the <a href="http://www.devicetree.org/">Device Tree</a> format is ongoing,
and <a href="http://elinux.org/images/5/5c/ELCE2013_-_DT_War.pdf">not without it's share of problems</a>.
</p>
<p>
<h2>Embedded Device Trees</h2>
So, what is an embedded device tree, and how do we describe it?
Let's look at a common example, say the  <a href="http://beagleboard.org/BLACK">BeagleBone Black</a>, which uses an OMAP3 System-on-Chip from Texas Instruments.
A very (very) simplified example, including just the CPU and it's main memory, would look something like this :
</p>
<p>
<table>
<tr>
<td>&nbsp;</td>
<td>
<img src="{{site.url.images}}/news/sff/beagleboneblack.png" alt="BeagleBone Black" title="BeagleBone Black"/>
</td>
<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>
<img src="{{site.url.images}}/news/devicetree/device-tree-bbb.png" alt="BeagleBone Black Device Tree" title="BeagleBone Black Device Tree"/>
</td>
<td>&nbsp;</td>
</tr>
</table>
</p>
<p>
The corresponding <a href="http://www.devicetree.org/">Device Tree Source (.dts)</a> file for the above would look something like :
{% highlight c linenos %}
{
        model      = "TI AM335x BeagleBone Black";
        compatible = "ti,beaglebone-black",
                     "ti,am335x-boneblack",
                     "ti,am335x-bone",
                     "ti,am33xx";
        cpus {
                cpu@0 {
                       cpu0-supply = <&dcdc2_reg>;	
                };	
        };	
        memory {	
                device_type = "memory";
                reg = <0x80000000 0x10000000>; /* 256 MB */	
        };
};
{% endhighlight %}
</p>
<p>
Of course, the actual Device Tree Source (.dts) file, in this case, the 
<a href="http://git.ti.com/wilink8-wlan/wilink8-wlan-ti-linux-kernel/blobs/9bf81aa9157a358fa53ab015e01c08bc68788709/arch/arm/boot/dts/am335x-bone-common.dtsi">am335x-bone-common.dtsi</a> include file has much more detail, but I think you can get the general idea more easily from a simplified snippet.
We will delve into some of the specifc details of the <a href="http://www.devicetree.org/">Device Tree Source (.dts)</a> file format a bit later on.
</p>
<p>

</p>
<p>

</p>
<p>

</p>
