---
layout: post
category: news
title: "Smart Device Trees"
date: 2015-02-06 09:30
quote: A smart man makes a mistake, learns from it, and never makes that mistake again. But a wise man finds a smart man and learns from him how to avoid the mistake altogether. 
quote_author: Roy H. Williams
product_slug: devicetree
licensing: false
cc_by_sa: false
comments: true
---
<p>
Lately, I've been working on automatic discovery and configuration of devices and peripherals, using 
<a href="http://www.patternagents.com/news/2015/01/25/the-blob.html">Binary Level Objects</a>, like the
<a href="http://www.intel.com/content/www/us/en/servers/ipmi/information-storage-definition-rev-1-2.html">IPMI FRU</a>, the
<a href="http://www.devicetree.org/Device_Tree_Usage">Device Tree</a> and
<a href="http://www.devicetree.org/Device_Tree_Usage">Device Tree Overlay</a> formats.
Typically these have been implemented using just a "dumb" storage device,
like an <a href="http://en.wikipedia.org/wiki/EEPROM">EEPROM</a>, or an 
<a href="http://en.wikipedia.org/wiki/Secure_Digital">SDcard</a>, or perhaps a 
<a href="http://www.st.com/web/en/catalog/mmc/FM76/CL1766/SC1412/SS1812">Dynamic NFC/RFID tag</a>.
So, what then, do I mean by a "Smart" Device Tree?
<br><br>
</p>
<!-- more -->
<p>
<h2>Low Cost Microcontrollers</h2>
A few years ago, we were all abuzz about the "$1" ARM Cortex devices like the Cortex M-3, 
and later, the Cortex M-0 devices.
Hat's off to <a href="http://www.arm.com/">ARM Ltd.</a> for making 32-bit microcontrollers ubiquitous.
By now (2015), the cost of simple microcontrollers are more about the amount of flash memory
and the features included, than the microcontroller itself. These days I can usually find a 
low feature, low pin count, microcontroller for little more than the cost of a "dumb" storage device.
Additionally, the smartphone and mobile handset market have led the push to smaller packages, 
and lower power microcontrollers, in order to increase the battery powered run time. So the 
threshold for adding "intelligence" (i.e. a microcontroller) to solving hardware design problems
has gotten very low indeed.
</p>
<p>
<h2>Common Data Structures</h2>
Regardless of what kind of microcontroller and development environment you choose for your products,
 you'll soon realize that you need to keep track of a lot of <a href="http://en.wikipedia.org/wiki/Metadata"><i>metadata</i></a> 
which most development enviroments will leave up to you, the user. I'm talking about the kinds of data you need regardless of
what kind of product you are building, and what kind of firmware/software you are using. 
How do you keep track of things
like Serial Numbers, Version Numbers, MAC ID's, Interface Addresses, etc. in a uniform way?
Where do you keep them in your firmware (program)and how do you keep them current
without having to change the firmware itself?
From a complex Drone design to a more simple toaster oven, wouldn't it be good
if we could handle all that <a href="http://en.wikipedia.org/wiki/Metadata">metadata</a>
in a more simple and consistant way?     
</p>
<h2>Common Interfaces</h2>
<img class="illo" src="{{site.url.images}}/news/devicetree/smart-dev-tree.png" alt="Example Low Cost Microcontroller" title="Example Low Cost Microcontroller"/>
Most of the low cost microcontrollers today have a good mix of common interfaces, like 
<a href="http://en.wikipedia.org/wiki/I%C2%B2C">I2C</a>, 
<a href="http://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus">SPI</a>, and 
<a href="http://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter">UARTs</a>.
And most vendors also include some simple emulation functions, that allow you to reserve an
area of the microcontroller's flash memory to emulate a "dumb" storage device using those
interfaces. In other words, if you use an I2C EEPROM emulation function on most microcontrollers,
then to the outside world connecting to your microcontroller, your microcontroller looks exactly 
like a "dumb" I2C EEPROM. The same concept applies if you bind one of your SPI Slave controllers 
to a SPI EEPROM emulator function, then to the outside world, your microcontroller would 
look just like a "dumb" SPI EEPROM.  
</p>
<p>
<h2>Device Tree Flash Mapping</h2>
Of course, "under the hood", this solution is not "dumb" at all. 
When you utilize an I2C or SPI EEPROM emulation function, 
you generally pass a pointer to the flash memory area that you want reserved 
for the EEPROM memory emulation. If we are not going to do much else with 
microcontroller we might even reserve the majority of the microcontrollers flash memory.
Now, imagine for a moment that reserved flash memory area is used to hold the 
Flattened Device Tree "BLOB" of binary data, perhaps for an expansion board.
What we have now, is a "Smart Device Tree". We can even access that
Device Tree from two different interfaces, namely 
<a href="http://en.wikipedia.org/wiki/I%C2%B2C">I2C</a>, and 
<a href="http://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus">SPI</a>
at the same time. In my 
<a href=http://localhost:4000/news/2015/02/02/devicetree-on-modbus.html">last article</a>
I demonstrated how to map the Device Tree onto a <a href="http://en.wikipedia.org/wiki/Modbus">Modbus</a> 
RTU using a UART interface. I've successfully employed these techniques in several customer designs.
</p>
<p>
<h2>Adding Some Intelligence</h2>
You'll notice that I put an "Internal Temperature" block in the above microcontroller block
diagram, as most microcontrollers have a junction temperature measurement that can be used
to read the internal temperature of the device. Now, imagine for a moment, that the microcontroller
takes a temperature measurement every second of so, and maintains a running average temperature.
So, what happens if we store that as a property into the Flattened <a href="http://www.devicetree.org/">Device Tree</a> (BLOB)?
Well, now we have a <i>Smart Device Tree</i>.
</p>
<p>
<h2>Summary</h2>
Adding the Device Tree data structure to an embedded micrcontroller design is 
pretty straightforward and simple, and enables the automatic discovery and configuration of 
a variety of devices and peripherals; and that is just the beginning of what we can do with a
<i>Smart Device Tree</i>. 
</p>
<p>   
<h2>References, Footnotes, and more...</h2>
<ol>
<li><a href="http://www.modbus.org/specs.php">Modbus Specifications</a></li>
<li><a href="http://events.linuxfoundation.org/sites/events/files/slides/petazzoni-device-tree-dummies.pdf">Device Tree for Dummies - Thomas Petroni</a></li>
<li><a href="https://learn.adafruit.com/introduction-to-the-beaglebone-black-device-tree">BeagleBlack Device Tree Tutorial - Adafruit</a></li>
<li><a href="http://xillybus.com/tutorials/device-tree-zynq-1">Xilinx Device Tree Tutorial - Xillybus</a></li>
<li><a href="http://xillybus.com/tutorials/device-tree-altera-soc-cyclone">Altera Device Tree Tutorial - Xillybus</a></li>
<li><a href="https://blueprints.launchpad.net/ubuntu/+spec/mobile-lucid-arm-device-tree-support">ARM Device Tree Support - Ubuntu</a></li>
<li><a href="http://www.alterawiki.com/wiki/Sopc2dts">Altera Device Tree Support - Altera</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/devicetree/bindings/">Index of Device Tree Bindings - kernal.org</a></li>
<li><a href="http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/plain/Documentation/devicetree/bindings/graph.txt">Device Tree Graphing - kernal.org</a></li>
<li><a href="https://packages.debian.org/wheezy/libfdt-dev">libfdt - manipulating FDT Blobs - David Gibson</a></li>
<li><a href="http://www.informit.com/articles/article.aspx?p=1647051&seqNum=5">Linux Bootloaders - informit.com</a></li>
<li><a href="http://haifux.org/lectures/288/haifux-devicetree.pdf">Device Tree PnP - Eli Billauer</a></li>
<li><a href="https://lkml.org/lkml/2013/1/7/366">Device Tree Overlay Manager - Pantelis Antoniou</a></li>
<li><a href="https://lkml.org/lkml/2012/11/5/615">Device Tree Overlay Proposal - Grant Likely</a></li>
<li><a href="https://github.com/cdsteinkuehler/beaglebone-universal-io">BeagleBlack Univeral I/O - cdsteinkuehler</a></li>
<li><a href="http://kilobaser.com/blog/2014-07-28-beaglebone-black-devicetreeoverlay-generator#dtogenerator">BeagleBlack Device Tree Overlay Generator - Kilobaser</a></li>
<li><a href="http://derekmolloy.ie/gpios-on-the-beaglebone-black-using-device-tree-overlays/">GPIOs on the Beaglebone Black using the Device Tree Overlays- derek molloy</a></li>
<li><a href="http://elinux.org/images/f/f2/Supporting_200_Different_Expansionboards_The_Broken_Promise_of_Devicetree.pdf">Supporting 200 Different Expansion Boards -  elinux.org</a></li>
<li><a href="http://events.linuxfoundation.org/sites/events/files/slides/presentation_3.pdf">DT, The Disaster so Far - Mark Rutland</a></li>
<li><a href="http://elinux.org/images/5/5c/ELCE2013_-_DT_War.pdf">Board File to Device Tree Migration - Pantelis Antoniou</a></li>
<li><a href="http://lwn.net/Articles/616859/">Device Tree Overlays - Jonathon Corbet</a></li>
</ol>
</p>



