
<!DOCTYPE html>
<!--[if IE 8]>         <html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <title>: News</title>

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width" />

  <meta name="robots"                  content="noodp, noydir, noarchive"         />
  <meta name="description"        content="PatternAgents - News"    />
  <meta name="abstract"              content="PatternAgents - News"       />
  <meta name="classification"  content="" />
  <meta name="keywords"              content="PatternAgents, faq, press, press release, news, investors, investment, license, licensing, franchise"       />

  <link rel="apple-touch-icon" type="image/png" href="/img/logos/apple-touch-icon-144x144.png" />
  <!--  <link rel="icon" type="image/png" href="http://www/patternagents.com/img/logos/apple-touch-icon.png"/>  -->

  <!-- Ubuntu for logo -->
  <link href='https://fonts.googleapis.com/css?family=Ubuntu:400,700' rel='stylesheet' type='text/css'>

<!--[if lte IE 8]>
    <link rel="stylesheet" href="/css/app-old-ie.css">
<![endif]-->
<!--[if gt IE 8]><!-->
    <link rel="stylesheet" href="/css/app.css">
<!--<![endif]-->
  
<!-- Begin MailChimp Signup Form -->
 <link href="https://cdn-images.mailchimp.com/embedcode/classic-081711.css" rel="stylesheet" type="text/css">
 <style type="text/css">
	#mc_embed_signup{position:absolute; top:0; left:0; width:100%; height:100%; background-color:rgba(0,0,0,.8); display:block; z-index:10000; }
	#mc_embed_signup form{position:fixed; top:5%; left:5%; right:5%; bottom:5%; width:60%; font:normal 100% Helvetica,Arial,sans-serif; font-size:14px; border-radius:4px; border:3px; padding:10px; background-color:#eee; color:#000; text-align:left;max-height:800px;overflow-y:auto;overflow-x:hidden;}
	#mc_embed_signup a.mc_embed_close{background:transparent url(http://downloads.mailchimp.com/img/closebox.png) no-repeat; display:block; height:30px; width:30px; text-indent:-999em; position:absolute; top:10px; right:10px; display:none; }
 </style>

<!-- Begin Google Analytics -->
 <script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-38592761-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'https://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
  </script>

</head>

<body class="news">
 <!-- 
# Note: I cannot get the plugin system to work, and so
# we are using the built-in excerpt mechanism, under which
# every post must have an excerpt. Sorry!
 -->


































<header>
<!-- Cookie Consent Form -->
<script type="text/javascript" src="https://www.FreePrivacyPolicy.com/cookie-consent/releases/3.0.0/cookie-consent.js"></script>
<script type="text/javascript">
document.addEventListener('DOMContentLoaded', function () {
    cookieconsent.run({"notice_banner_type":"headline","consent_type":"express","palette":"dark","change_preferences_selector":"#changePreferences","language":"en","website_name":"patternagents.com","cookies_policy_url":"https://patternagents.com/policies/index.html"});
});
</script>
<noscript><a href="https://www.freeprivacypolicy.com/cookie-consent/">Cookie Consent Necessary for GDPR/EU Compliance</a></noscript>
<!-- End Cookie Consent From -->
  <div class="head-container">
	  <div class="col">
	    <a href="">
	      <h1>Pattern&#8203;<b>Agents</b> <span class="tag-line">Connecting the electronics design community</span></h1>
	    </a>
	  </div>
  </div>
</header>



<div class="row"><div class="col">
<nav class="toggle">
  <h2><a href="#" title="(click to expand)"><span class="menu-icon">&#9776;</span> Go to:</a></h2>
  <ul>
    <li class="nav-store"><a href="">Store</a></li>
    <li class="nav-projects"><a href="">Projects</a></li>
    <li class="nav-support"><a href="">Support</a></li>
    <li class="nav-about"><a href="">About</a></li>
    <li class="nav-news"><a href="">News</a></li>
  </ul>
</nav>
</div></div>


  
  


<main class="row">
  
  <div class="col major">
    
  <div class="row">
    <div class="col maj_major">
      
  
  
    
    <article>
      <header>
        <h1 class="entry-title"><a href="/news/2019/09/11/the-summer-of-osc.html">The Summer of OSC</a></h1>
        
          <p class="meta">
            September 11, 2019
          </p>
        
      </header>
      <div class="entry-content">
      
      
      

<blockquote>
	<p>I knew when I met you an adventure was going to happen.</p>
	<p>&mdash;Winnie the Pooh</p>
</blockquote>

    I just love summer music festivals, whether I'm working on them or just attending, they are a welcome change from
my largely indoor profession of designing electronic systems. This year, working stage management at Beloved 
and other festivals, I noticed a common thread across a variety of stages, which I'll call "the Summer of OSC".  
</p>
<!-- more -->

</div>
      <footer>
        <a rel="full-article" href="/news/2019/09/11/the-summer-of-osc.html"></a>
      </footer>
    </article>
  
    
    <article>
      <header>
        <h1 class="entry-title"><a href="/news/2019/08/11/MIDI_to_DMX.html">MIDI to DMX</a></h1>
        
          <p class="meta">
            August 11, 2019
          </p>
        
      </header>
      <div class="entry-content">
      
      
      

<blockquote>
	<p>Learn to light a candle in the darkest moments of someoneâ€™s life. Be the light that helps others see; it is what gives life its deepest significance.</p>
	<p>&mdash;Roy T. Bennett, The Light in the Heart</p>
</blockquote>

    There are many ways to synchonize lights and music/sounds, and here is a simple MIDI sound to DMX lighting bridge demonstration using the new PatternAgents MIDI and DMX FeatherWing boards. We'll assign MIDI notes to DMX lighting channels with velocity translating to brightness.
</p>
<!-- more -->
<iframe width="1218" height="685" src="https://www.youtube.com/embed/vBVFalMKICw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

</div>
      <footer>
        <a rel="full-article" href="/news/2019/08/11/MIDI_to_DMX.html"></a>
      </footer>
    </article>
  
    
    <article>
      <header>
        <h1 class="entry-title"><a href="/news/2017/03/10/thingSoC.html">thingSoC CrowdSupply funded and shipped</a></h1>
        
          <p class="meta">
            March 10, 2017
          </p>
        
      </header>
      <div class="entry-content">
      
      
      

<blockquote>
	<p>Change your thoughts and you change your world.</p>
	<p>&mdash;Norman Vincent Peale</p>
</blockquote>

    Our <b>thingSoC</b> thingSoC CrowdSupply campaign was funded, and we have shipped out boards to all of our backers. Thank You!
</p>
<!-- more -->

</div>
      <footer>
        <a rel="full-article" href="/news/2017/03/10/thingSoC.html"></a>
      </footer>
    </article>
  
    
    <article>
      <header>
        <h1 class="entry-title"><a href="/news/2016/01/10/thingSoC.html">thingSoC nears release...</a></h1>
        
          <p class="meta">
            January 10, 2016
          </p>
        
      </header>
      <div class="entry-content">
      
      
      

<blockquote>
	<p>Live as if you will die tomorrow. Learn as if you will live forever.</p>
	<p>&mdash;Mahatma Ganghi</p>
</blockquote>

    <b>thingSoC</b> defines a physical, hardware socket system for inter-operable printed circuit boards,
with a data centric firmware model for automatic device discovery, and a software API for interacting with the system.
</p>
<!-- more -->
<p>
<b>thingSoC</b> provides a vendor neutral and device agnostic socket standard, 
using a virtual hardware socket definition; so you are not locked in to any proprietary solutions.
This means that the IoT applications you develop can be easily migrated 
without having to re-write your software.
<p>
As many of you know, we've been working on the thingSoC socket concept for quite a while now,
and it is finally approaching it's first official release.  
<p>
<h3>thingSoC Features:</h3>
<ul>
  <li>Auto-Discovery of attached peripherals and radios </li>
  <li>Configuration of attached peripherals </li>
  <li>Monitoring and Instrumentation of attached peripherals </li>
  <li>Standard metadata store for configuration and parameter information</li>
  <li>An Open-Source Hardware Standard (OSHW)</li>
</ul>

</div>
      <footer>
        <a rel="full-article" href="/news/2016/01/10/thingSoC.html"></a>
      </footer>
    </article>
  
    
    <article>
      <header>
        <h1 class="entry-title"><a href="/news/2015/08/25/IoT-RTLS.html">Real-Time Location Systems for IoT</a></h1>
        
          <p class="meta">
            August 25, 2015
          </p>
        
      </header>
      <div class="entry-content">
      
      
      

<blockquote>
	<p>There is a saying that every nice piece of work needs the right person in the right place at the right time.</p>
	<p>&mdash;Benoit Mandelbrot</p>
</blockquote>

    <p>
I've worked on a number of Real-Time Location Systems (RTLS) over the years, including Global Positioning Systems (GPS),
and Radio Frequency Location Systems (RFLS), and all of them have had their share of problems with accuracy, signal interferance, 
and signal loss. My friend David just demonstrated a new Real-Time Location System (RTLS) for me this week, based on the
the <a href="https://en.wikipedia.org/wiki/IEEE_802.15.4">IEEE_802.15.4 standard</a>, using an Ultra-Wide Band (UWB) tranceiver
from <a href="https://www.decawave.com/">decaWave</a>, the <a href="https://www.decawave.com/products/dw1000">DW1000</a>.
With up to ten centimeter (10cm) indoor position accuracy of moving objects, it's accuracy sets a new standard.
</p>
<!-- more -->
<p>
<h3>Real-Time Location Systems (RTLS)</h3>
There have been many different approaches to Real-Time Location Systems (RTLS), largely separated into indoor and outdoor applications.
Global Positioning System (GPS) devices have come down in price significantly over the last few years, and can now be found in
most outdoor applications (cars, boats, etc.) as well as cell phones and handsets. Unfortunately, GPS devices don't function well  
for indoor applications, and can often have problems outdoors as well, under trees and in canyons, for example.
Real-Time Location Systems (RTLS) for indoor applications have relied on received Radio Frequency Signal Strength (RSSI)
using <a href="https://en.wikipedia.org/wiki/Wi-Fi_positioning_system">Wi-Fi positioning</a> or 
<a href="https://en.wikipedia.org/wiki/IBeacon">Bluetooth Beacons</a>. However, both of these technologies have both limited
range and accuracy. 
<a href="https://www.decawave.com/products/trek1000"><img class="illo" src="/news/iot/trek1000.png" alt="TREK1000 Evaluation" title="TREK1000 Evaluation"/></a>
<p>
<h3>Real-Time Location Applications</h3>
The applications for Real-Time Location are numerous, from "Where did I leave my keys?", or commercial asset tracking, 
to people and personnel tracking. Applications have been traditionally limited by the accuracy and range of existing solutions,
as well as the cost of implementation. The <a href="https://www.decawave.com/">decaWave</a>, 
<a href="https://www.decawave.com/products/dw1000">DW1000</a> device aims to remove those limitations by providing a lower cost
solution with high accuracy.
<p>
<h3>DW1000 - Hardware Features</h3>
The DW1000 Integrated Circuit enables a new approach to Real Time Location and Indoor Positioning Systems : 
</p>
<p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/IEEE_802.15.4">IEEE_802.15.4 Ultra-Wide Band Tranceiver</a></li>
<li>Ten Centimeter (10 cm) indoor position accuracy of objects</li>
<li>High Speed tracking of moving objects, up to 500 meters/second (1100 mph)</li> 
<li>Six megabit (6.8 megabit) per second data rate for Sensor applications</li>
<li>Nine Hundred foot (290 meters) communications range</li>
<li>High Tag density tracking (11,000 tags within a 20 meter radius)</li>
<li>High Immunity to Multipath Fading</li>
<li>Low power consumption for longer battery lifetime</li>
</ul>
<a href="https://www.decawave.com/products/evk1000-evaluation-kit"><img class="illo" src="/news/iot/dw1000_evb.png" alt="EVK1000 Evaluation Board" title="EVK1000 Evaluation Board"/></a>
</p>
<p>
<h3>EVK1000 - Evalution Board</h3>
The EVK1000 Evalution Board incorporates the DW1000 UWB IC, an ARM Cortex-M3 (STM32F105) microcontroller,
and a 16x2 line character LCD module. The EVK1000 Evalution Board includes a standard twenty (20) pin JTAG programming
header, and we were able to quickly access it using our Segger J-Link programming adaptor. The DW1000 uses 
a high speed SPI connection to the ARM Cortex-M3 (STM32F105) microcontroller for high thoughput. 
</p>
<h3>DWM1000 Module</h3>
<a href="https://www.decawave.com/products/dwm1000-module"><img class="illo" src="/news/iot/dwm1000.png" alt="DWM1000 Module" title="DWM1000 Module"/></a>
The DM1000 can either be purchased as a discrete package (48 pin QFN) or as the DWM1000 Module. 
The DWM1000 Module includes voltage regulation, bypass capacitors, RF Balun and a chip antenna.
If you are not an accomplished RF layout designer, the module is a simple way to embed the DM1000
in your end product.
</p>

</div>
      <footer>
        <a rel="full-article" href="/news/2015/08/25/IoT-RTLS.html"></a>
      </footer>
    </article>
  
    
    <article>
      <header>
        <h1 class="entry-title"><a href="/news/2015/06/19/IoT-SoCs.html">New IoT SoCs</a></h1>
        
          <p class="meta">
            June 19, 2015
          </p>
        
      </header>
      <div class="entry-content">
      
      
      

<blockquote>
	<p>We're still in the first minutes of the first day of the internet revolution.</p>
	<p>&mdash;Scott Cook</p>
</blockquote>

    <p>
There have been a number of purpose built System-on-Chip (SoC) devices
intended for connecting to the Internet of Things (IoT). 
Examples include the 
<a href="https://www.esp8266.com/">ESP8266 (WiFi)</a>, the 
<a href="https://www.ti.com/product/cc2530">CC2530 (Zigbee)</a>, or the
<a href="https://www.st.com/web/catalog/sense_power/FM2185/SC1845/PF253167">Spirit1 (sub-1GHz)</a>,
for different wireless connection standards. 
In the Bluetooth & ANT IoT connectivity space, 
Nordic Semiconductor has been playing a winning hand with their ARM Cortex-M0 based nRF51822 IoT SoC,
and they have just seriously upped the ante with their new ARM Cortex-M4F based 
<a href="https://www.nordicsemi.com/eng/Products/Bluetooth-Smart-Bluetooth-low-energy/nRF52832">nRF52832</a> IoT SoC.
It's a multiprotocol RF SoC that supports Bluetooth Smart, ANT, 
Near Field Communication (NFC), Out-of-Band Pairing (OoB), Ultra-Low Power (ULP), and more.
</p>
<!-- more -->
<p>
<h3>nRF52832 - 2.4GHz Multiprotocol RF SoC</h3>
The new <a href="https://www.nordicsemi.com/">Nordic Semiconductor</a> Multiprotocol RF SoC IC has
just been announced, and the <a href="https://www.nordicsemi.com/eng/Products/Bluetooth-Smart-Bluetooth-low-energy/nRF52832">nRF52832</a> IoT SoC
is a pretty amazing piece of design work. You can get an idea of the high level of integration just looking at the block diagram :
</p>
<a href="https://www.nordicsemi.com/eng/nordic/download_resource/48726/2/92931685"><img src="/news/iot/nRF52832_block_diagram.png" alt="nRF52832 Block Diagram" title="nRF52832 Block Diagram"/></a>
<p>
<h3>nRF52832 - Hardware Features</h3>
A quick rundown of the IoT SoC hardware features - 
<br>and why we're really excited about working with this new RF platform : 
</p>
<p>
<ul>
<li>Multiprotocol 2.4Ghz Radio (Bluetooth Smart, ANT, Proprietary)</li>
<li>NFC-A Near Field Communication (use NFC for seamless Bluetooth pairing...)</li>
<li>64Mhz ARM Cortex-M4F (with Floating Point and DSP instructions)</li>
<li>512kB FLASH memory (enough for the stack AND your application)</li>
<li>64kB SRAM (enough to make use of those DSP instructions)</li>
<li>Twelve (12) Bit Analog-to-Digital Converter (200 kps ADC/Sensor Update Rate)</li>
<li>Memory mapped FIFOs memories with Direct Memory Access (EasyDMA)</li>
<li>Twenty (20) Channel Programmable Peripheral Interconnect <br>(PPI for non-CPU/autonomous I/O operations)</li>
<li>I2S Audio supported by DMA (Digital Audio Capabilities with ARM DSP)</li>
<li>128-Bit Security/Encryption Co-processor (AES ECB, CCM, AAR)</li>
<li>32KHz RTC clock/control oscillator (Real-Time Clock)</li>
<li>32MHz RTC clock/control oscillator (Bluetooth/RF Clock)</li>
<li>Internal DC-DC Buck Converter Power Supply (Low External Parts Count)</li>
<li>Power Management Interface Controller (PMIC for individual peripheral power control)</li>
<li>Prototype Friendly 48 Pin QFN Package (Hand Solder)</li>
<li>Mobile/Miniature/Production WL-CSP Package (Handset)</li>
</ul>
</p>
<p>
I have to say, this is an ideal RF architecture from my point of view,
and I think that the Nordic engineers came up with a really excellent SoC design.
If someone gave me a team of ASIC designers and a budget, it's pretty much what I'd want to design
for a Bluetooth Smart/ANT IoT System-on-Chip.
</p>
<h3>Improving the User Experience - Seamless Device Pairing</h3>
<a href="https://www.nordicsemi.com/eng/nordic/download_resource/48726/2/92931685"><img class="illo" src="/news/iot/nfc_bluetooth_pair.png" alt="NFC Bluetooth Pairing" title="NFC Bluetooth Pairing"/></a>
<p>
By including a Near Field Communications (NFC-A) module with proximity detection and Wake-on-NFC capability,
the <a href="https://www.nordicsemi.com/eng/Products/Bluetooth-Smart-Bluetooth-low-energy/nRF52832">nRF52832</a> IoT SoC
is really going to improve the user experience with seamless device pairing (no codes to enter),
and proximity operation.  The Near Field Communications (NFC-A) module can provide the pairing keys,
so that an authorized device can connect automatically - no fuss - no muss...
</p>
<p>
The proximity detection capability will enable a whole variety of "walk up - turn on" usage scenarios
and is a good addition to the NFC capability.
</p>
<h3>New 2.4GHz Multiprotocol Radio</h3>
<p>
The new 2.4GHz multiprotocol radio module supports 
Bluetooth Smart, and ANT as well as other proprietary protocols.
It is also backward compatible (on air compatible) with 
the earlier Nordic radios, like the nRF24AP, nRF24L and nRF51 Series.
The RF output power is now scalable from a maximum of +4dBm down to -20dBm in 4dB
steps; with increased sensitivity range(s) from -96dBm to -89dBm, depending on the data rate.
</p>
<h3>Autonomous Peripheral Communications</h3>
<p>
I wish that more ASSP/ASIC designers understood how offloading the peripheral communications from the CPU
to dedicated hardware can both lower the power budget <b>and</b> increase the I/O throughput. The Nordic team
clearly got that right with their new  Programmable Peripheral Interconnect (PPI) system, which provides a
twenty (20) channel bus for direct and autonomous peripheral communications, and offloads that work from the CPU.
That means the CPU can be sleeping more often, saving those precious microamps of battery power.  
</p>
<h3>ARM Cortex-M4F Central Processor</h3>
<p>
This was a really smart move by the Nordic team, as the ARM Cortex-M4F CPU is both powerful,
and still relatively power efficient. I've been using the ARM Cortex-M4F for a while now,
on the excellent <a href="https://www.pjrc.com/teensy/teensy31.html">Teensy 3.1</a> platform
designed by Paul Stoffregen, and it is a really nice processor architecture - with hardware support
for DSP instructions and floating point operations. 
</p>
<p>
Using the ARM Cortex-M4F Central Processor means that the 
<a href="https://www.nordicsemi.com/eng/Products/Bluetooth-Smart-Bluetooth-low-energy/nRF52832">nRF52832</a> IoT SoC
has enough CPU horsepower to handle a variety of tasks, especially with their PPI I/O offloading system.
One of the problems with using the <a href="https://www.ipso-alliance.org/technical-information/getting-started-with-smart-objects">Internet Protocol Smart Objects (ISPO)</a> standard is that the common sensor value returns are all in floating point format -
well no problem with the <a href="https://www.nordicsemi.com/eng/Products/Bluetooth-Smart-Bluetooth-low-energy/nRF52832">nRF52832</a> IoT SoC,
it's got floating point operation covered. (Try that on an 8bit i8051 IoT SoC, and you'll be waiting a while...)
</p>
<h3>The Rundown</h3>
So, how does the new Nordic <a href="https://www.nordicsemi.com/eng/Products/Bluetooth-Smart-Bluetooth-low-energy/nRF52832">nRF52832</a> IoT SoC
stack up against the other leading Bluetooth SoCs? <br>Here's a quick comparison :
</p>
<table border=2>
<tr align="center">
<td>Bluetooth SoC</td>
<td>Mode(s)</td>
<td>CPU</td>
<td>Flash</td>
<td>RAM</td>
<td>RX/TX Current</td>
<td>Price (1K)</td>
</tr>
<tr align="center">
<td>TI CC254x</td>
<td>Single Mode v4.0</td>
<td>8051</td>
<td>128kB/256kB</td>
<td>8kB</td>
<td>17.9mA / 18.2mA to 14.7mA / 14.3mA</td>
<td>~$5</td>
</tr>
<tr align="center">
<td>TI CC256x</td>
<td>Dual Mode Classic + BLE/ANT</td>
<td>External</td>
<td>External</td>
<td>External</td>
<td>15mA</td>
<td>~$2</td>
</tr>
<tr align="center">
<td>TI CC26xx</td>
<td>Single Mode BLE v4.1</td>
<td>Cortex-M3/M0</td>
<td>128kB</td>
<td>20kB</td>
<td>5.9mA</td>
<td>~$6</td>
</tr>
<tr align="center">
<td>Dialog DA14580</td>
<td>Single Mode BLE v4.1</td>
<td>Cortex-M0</td>
<td>32kB OTP</td>
<td>50kB</td>
<td>4.9mA</td>
<td>~$2</td>
</tr>

</div>
      <footer>
        <a rel="full-article" href="/news/2015/06/19/IoT-SoCs.html"></a>
      </footer>
    </article>
  
    
    <article>
      <header>
        <h1 class="entry-title"><a href="/news/2015/06/05/devicetree-more-flavors.html">More DeviceTree Flavors!</a></h1>
        
          <p class="meta">
            June 05, 2015
          </p>
        
      </header>
      <div class="entry-content">
      
      
      

<blockquote>
	<p>Variety's the very spice of life, that gives it all its flavor.</p>
	<p>&mdash;William Cowper</p>
</blockquote>

    <p>
Those of you who have been following what's been happening with hardware platforms like the Android, Beaglebone Black, Raspberry Pi,
and several other small Linux systems, have probably noticed a bit of divergence with respect to the Device Tree EEPROM
formats used on these platforms. So far, it's not seemed like the
simplification or standardization that everyone had hoped for; 
and what about cross-platform peripherals?
</p>
<!-- more -->
<p>
We now have the original 
Flattened Device Tree (fdt) format,
the Beaglebone Black "CAPE" EEPROM format, 
the Raspberry Pi "HAT" EEPROM format,  
and yes, even a few others.
Let's do a quick recap of these different EEPROM formats.
<p> 
<h3>Device Trees - Pick a Flavor</h3>
<p>
We have the "Original Recipe", flattened device tree (FDT) EEPROM format;
used on the PowerPC architecture, the Xilinx Virtex series with embedded PowerPC processor,
and other Freescale processors.
</p>
<p>
<a href="https://elinux.org/Device_Tree"><img src="/news/devicetree/FDT_EEPROM.png" alt="flattened device tree (FDT) EEPROM" title="flattened device tree (FDT) EEPROM"/></a>
</p>
<p>
Then we have the "extra crispy", BeagleBone Black(ened) EEPROM format for the TI OMAP processor :
</p>
<p>
<a href="https://www.adafruit.com/datasheets/BBB_SRM.pdf"><img src="/news/devicetree/BBB_EEPROM.png" alt="beaglebone black cape EEPROM" title="beaglebone black cape  EEPROM"/></a>
</p>
<p>
and then there's "Raspberry flavor", the Raspberry Pi EEPROM format for the Broadcom processor : 
</p>
<p>
<a href="https://github.com/raspberrypi/hats/blob/master/eeprom-format.md"><img src="/news/devicetree/RPI_EEPROM.png" alt="raspberry pi hat  EEPROM" title="raspberry pi hat EEPROM"/></a>
</p>
<p>
and "Vanilla Ice" for those of us working on FMC (FPGA Mezzanine Cards), the IPMI FRU EEPROM format : 
</p>
<p>
<a href="https://www.intel.com/content/dam/www/public/us/en/documents/product-briefs/platform-management-fru-document-rev-1-2-feb-2013.pdf"><img src="/news/devicetree/FRU_EEPROM.png" alt="IPMI FRU EEPROM" title="IPMI FRU EEPROM"/></a>
<BR>
Although technically, the IPMI FRU (Intelligent Peripheral Management Interface - Field Replacable Unit) 
is not related to the Linux Device Tree, it is used on many FPGA Mezzanine Cards to hold much of the same
design meta-data, so I'm chosing to include it here...
</p>
<p>
All of these EEPROM formats contain (more or less) the same meta-data about a system platform and/or it's add-on boards
and peripherals, and are used to discover the configuration information needed for those peripherals.
Things like product name, serial number, manufacturing date, and other important meta-data.
</p>
<p>
So, if they all contain (more or less) the same meta-data, why have so many formats? 
Historical reasons mainly, with different groups all working on the same problem;
and I think the folks designing add-on boards like "Capes", and "Hats" were also
looking for a more compact and easily addressable format than the flattened device tree (FDT).
</p>
<H3>Enter the Raspberry Pi HAT EEPROM format</H3>
<p>
When I first saw the <a href="https://github.com/raspberrypi/hats/blob/master/designguide.md">Raspberry Pi HAT specification</a> 
I wasn't sure that I liked the proposed <a href="https://github.com/raspberrypi/hats/blob/master/eeprom-format.md">Raspberry Pi EEPROM format</a>,
because the structure wasn't as simple to parse as the <a href="https://www.adafruit.com/datasheets/BBB_SRM.pdf">BeagleBone Black CAPE EEPROM  format</a>. The <a href="https://www.adafruit.com/datasheets/BBB_SRM.pdf">BeagleBone Black CAPE EEPROM  format</a> specifies fixed sized fields
at fixed offsets (which become constants at compile time), where as the other formats require a run time parser to interpret the "live" data structure. The <a href="https://github.com/raspberrypi/hats/blob/master/eeprom-format.md">Raspberry Pi EEPROM format</a> 
introduces the concept of ATOMs of data, basically a container format with checksum for each. 
The ATOM types include the typical header information as well as the PinMap and separate copy of the flattened device tree (FDT)
for each add-on card (i.e. HAT) as mandatory requirements. While I laud them for that effort at completeness,
making all of those ATOM fields mandatory is going to require a large EEPROM for each HAT; 
and it still doesn't really address the problem of cross-platform peripherals and different PinMap requirements. 
However, after looking at the HAT specification for a while, I really do like the simple and extendable ATOM concept for
arranging the storage of meta-data in the HAT EEPROM. I think that there is a lot that could be done (easily) using
different ATOM types for open (unencrypted), and secure (encrypted) areas within the EEPROM,
allowing important areas (like pinmap or microcode/firmware perhaps) 
to be secure/signed objects that need to be decrypted/verified before use.
</p>
<H3>The PinMap Problem</H3>
The most "system platform specific" meta-data contained in these EEPROM formats are things like the
"compatible" architecture binding, memory size/reservations, and the PinMap information; 
which determines what pins are used for inputs (switches, sensors), outputs (LED's, actuators), and other functions.
The PinMap information is specific to one "compatible" architecture binding, 
and so the PinMap information for the TI AM3358 (Beaglebone)
doesn't work for the Broadcom BCM2835 (RaspPi), etc. 
That could make it harder to design one product that
supports several different "compatible" architecture bindings.
In other words, if I have an add-on board that can plug into either a Beaglebone Black <i>OR</i> a Raspberry Pi,
(presumably with an adaptor) then how can I get it to work on both platforms with one EEPROM?
<br>The short answer right now, is that I don't think you can (easily). 
</p>
<p>
The idea behind having a PinMux section, is to be able to read configuration information that may
be required very early in the boot-up process, such as configuring the display screen in order to see the 
system bootup messages, as the system is booting. But the vast majority of add-on peripherals
won't need to redefine the basic pin multiplexing of the system platform to function,
they will simply add a peripheral to an existing I2C, SPI, or UART interface that has already
been defined by the FDT at boot time. So, why all the extra complexity?  
</p>
<H3>What's the Cross-Platform Use Model, Kenneth?</H3>
<p>
If you think about other (bus) interfaces, like USB, PCI, and PCI-express, 
they are more microprocessor make/model agnostic, because you design to the bus interface.
That's why for example, a PCI card works on a variety of micro-processors 
(Intel, AMD, ARM, etc.) because the bus definition is independent of the processor.
The same kind of approach could be taken with the Device Tree -
binding the microprocessor pins to (virtual) buses like UART1, I2C1, SPI2, etc.
and then binding the specific peripherals to those (virtual) buses using the device tree overlay.
That is possible today, but most designers bind peripherals directly to specific device pins.
</p>
<p>
So what is the Cross-Platform Use Model today? <br>
I suppose with the current device tree and overlay implementations 
you could erase and rewrite the product EEPROM for 
each different model of microprocessor, but that's a manufacturing/logistics nightmare.
Or you could use the FDT EEPROM format, and include a whole separate FDT tree for each
different model of microprocesor - but that's going to use a lot of EEPROM memory. 
So there are solutions today, they are just NOT very simple or elegant.
</p>
<h3>Suggestions for Cross-Platform Device Trees</h3>
<p>
<ol>
  <li>Headers for Peripherals should be Architecture Neutral : <br>
      Consider that someone is using an adaptor to put a Raspberry PI HAT on a BeagleBone Black, or visa versa.
      The "Header" information of Product Name/Model/UUID etc. is NOT Architecture specific - why make it so?
      The different device tree files for the same peripheral could be organized by the "compatible" tag. 
      For example, if I have a Cross-Platform peripheral named "myWidget", it could be something like :<br>
      /firmware/AM3358/myWidget.dts <br>
      /firmware/BCM2835/myWidget.dts<br>
  </li>
  <li>Put Architecture Specific Data in it's own ATOM : <br>
      If I need to include a different PinMap overlay for TI AM3358 and Broadcom BCM2835,
      how about making a PinMap ATOM type that includes the processor "compatible" field?
      That way, you can search the different PinMap ATOMs
      for your "compatible" processor type and just use that one.
      As a device overlay, it would be smaller in size, as it would just need to define the pins that are remapped.
  </li>
  <li>Define Pin Mapping in terms of Common Interface Types<br>
      While different microprocessors may have different pin names and types,
      they usually implement standard interfaces like UART1, I2C1, SPI2, GPIO, etc.
      If the primary, architecture specific FDT bound pins to standard interface types,
      then the device tree overlays could be much more generic. 
  </li>
</ol>
</p>
<p>
In coming articles, I'll present some ideas for mapping the standard interfaces like GPIO, UART1, I2C1, SPI2, etc.
as "Smart Objects", and how that can address some of the cross-platform interface problems facing designers today. 
</p>
<p>   
<h2>References, Footnotes, and more...</h2>
<ol>
<li><a href="https://events.linuxfoundation.org/sites/events/files/slides/petazzoni-device-tree-dummies.pdf">Device Tree for Dummies - Thomas Petroni</a></li>
<li><a href="https://learn.adafruit.com/introduction-to-the-beaglebone-black-device-tree">BeagleBlack Device Tree Tutorial - Adafruit</a></li>
<li><a href="https://xillybus.com/tutorials/device-tree-zynq-1">Xilinx Device Tree Tutorial - Xillybus</a></li>
<li><a href="https://xillybus.com/tutorials/device-tree-altera-soc-cyclone">Altera Device Tree Tutorial - Xillybus</a></li>
<li><a href="https://blueprints.launchpad.net/ubuntu/+spec/mobile-lucid-arm-device-tree-support">ARM Device Tree Support - Ubuntu</a></li>
<li><a href="https://www.alterawiki.com/wiki/Sopc2dts">Altera Device Tree Support - Altera</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/devicetree/bindings/">Index of Device Tree Bindings - kernal.org</a></li>
<li><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/plain/Documentation/devicetree/bindings/graph.txt">Device Tree Graphing - kernal.org</a></li>
<li><a href="https://packages.debian.org/wheezy/libfdt-dev">libfdt - manipulating FDT Blobs - David Gibson</a></li>
<li><a href="https://www.informit.com/articles/article.aspx?p=1647051&seqNum=5">Linux Bootloaders - informit.com</a></li>
<li><a href="https://haifux.org/lectures/288/haifux-devicetree.pdf">Device Tree PnP - Eli Billauer</a></li>
<li><a href="https://lkml.org/lkml/2013/1/7/366">Device Tree Overlay Manager - Pantelis Antoniou</a></li>
<li><a href="https://lkml.org/lkml/2012/11/5/615">Device Tree Overlay Proposal - Grant Likely</a></li>
<li><a href="https://github.com/cdsteinkuehler/beaglebone-universal-io">BeagleBlack Univeral I/O - cdsteinkuehler</a></li>
<li><a href="https://kilobaser.com/blog/2014-07-28-beaglebone-black-devicetreeoverlay-generator#dtogenerator">BeagleBlack Device Tree Overlay Generator - Kilobaser</a></li>
<li><a href="https://derekmolloy.ie/gpios-on-the-beaglebone-black-using-device-tree-overlays/">GPIOs on the Beaglebone Black using the Device Tree Overlays- derek molloy</a></li>
<li><a href="https://elinux.org/images/f/f2/Supporting_200_Different_Expansionboards_The_Broken_Promise_of_Devicetree.pdf">Supporting 200 Different Expansion Boards -  elinux.org</a></li>
<li><a href="https://events.linuxfoundation.org/sites/events/files/slides/presentation_3.pdf">DT, The Disaster so Far - Mark Rutland</a></li>
<li><a href="https://elinux.org/images/5/5c/ELCE2013_-_DT_War.pdf">Board File to Device Tree Migration - Pantelis Antoniou</a></li>
<li><a href="https://lwn.net/Articles/616859/">Device Tree Overlays - Jonathon Corbet</a></li>
</ol>
</p>

</div>
      <footer>
        <a rel="full-article" href="/news/2015/06/05/devicetree-more-flavors.html"></a>
      </footer>
    </article>
  
    
    <article>
      <header>
        <h1 class="entry-title"><a href="/news/2015/05/21/devicetree-smart-objects.html">Smart Device Trees meet Smart Objects</a></h1>
        
          <p class="meta">
            May 21, 2015
          </p>
        
      </header>
      <div class="entry-content">
      
      
      

<blockquote>
	<p>Itâ€™s not in the dreaming, itâ€™s in the doing.</p>
	<p>&mdash;Mark Cuban</p>
</blockquote>

    <p>
<a href="https://www.ipso-alliance.org/technical-information/getting-started-with-smart-objects">Internet Protocol Smart Objects (ISPO)</a> 
have the potential to provide much better interoperability for Internet connected devices,
by standardizing the data (and the meta-data) exchanged between those devices.  While the market has seen an explosion of new IoT devices, 
the vast majority can not "talk" to each other in any meaningful way, since they don't know each others data formats and device capabilities.
Internet Protocol Smart Objects (ISPO) outlines several "Smart Object" classes for sensors and actuators with well known data formats.
For the past several articles, I've been discussing Device Trees and their application in describing the hardware capabilities of
various embedded platforms, which seems to be exactly what we need to automatically generate the directory of 
<a href="https://www.ipso-alliance.org/technical-information/getting-started-with-smart-objects">Internet Protocol Smart Objects (ISPO)</a>
for IoT devices. I think it's time for Smart Objects to meet Smart Device Trees...
</p>
<!-- more -->
<p>
The development (and deployment) of new technologies usually occurs in phases, often as applicable 
standards begin to become mainstream. The HTML standard spawned the first phase of the Internet, 
followed by the <a href="https://en.wikipedia.org/wiki/Browser_wars">"Browser Wars"</a> of the late 1990's. 
As the Internet matured to "Internet 2.0" and beyond, much of those early proprietary HTML enhancements 
were replaced as the HTML 5.0 standard was adopted, and we began to have much
better web browser interoperability and usability. Unfortunately, the "Internet of Things" as it stands today,
is about where we were back in "Internet 1.0", but that is beginning to change as new standards like
<a href="https://www.ipso-alliance.org/technical-information/getting-started-with-smart-objects">Internet Protocol Smart Objects (ISPO)</a>
are becoming adopted.
</p>
<h3>Beyond Simple Protocol Compatibility</h3>
<p>
Much of the effort around creating the "Internet of Things" to date, has been focused on developing standards to
carry data to and from "the Cloud" to "edge Devices", using various connectivity protocols. 
Both <a href="https://coap.technology/">CoAP</a> (RFC-7252) and <a href=""https://mqtt.org/">MQTT</a>
have emerged as useful IoT connectivity protocols. Unfortunately, these are only connectivity standards
and they do not specify the format of the data or meta-data tranferred using them.
It's like asking for the temperature in the English language in Fahrenheit, 
but getting a response in the French language in Celsius.
Unless you speak French, you received the information, but can't comprehend it.
This illustrates the heart of the problem for IoT designers today.
</p>
<p>
<a href="https://www.ipso-alliance.org/technical-information/getting-started-with-smart-objects">Internet Protocol Smart Objects (ISPO)</a>
were designed to facilitate data exchange and interoperability by providing a common object model, 
consisting of a URI template and known data types.  <a href="https://www.ipso-alliance.org/technical-information/getting-started-with-smart-objects">Internet Protocol Smart Objects (ISPO)</a> can be likened to web pages for devices, employing consistant data types for RESTful web objects.
Some of these IPSO objects are quite specific, like :
<ul>
<li>Temperature sensor</li>
<li>Humidity sensor</li>
<li>Illuminance sensor</li>
<li>Accelerometer</li>
<li>Magnetometer</li>
<li>Barometer</li>
<li>Presence sensor</li>
</ul>
While others are more generic :
</p>
<p>
<ul>
<li>Digital input</li>
<li>Digital output</li>
<li>Analog input</li>
<li>Analog output</li>
<li>Power measurement</li>
<li>Actuation</li>
<li>Set point</li>
</ul>
The <a href="https://www.ipso-alliance.org/technical-information/getting-started-with-smart-objects">Internet Protocol Smart Objects (ISPO)</a>
"Starter Pack 1.0" includes both the object definition and data format, allowing for a meaningful exchange of information.
</p>
<p>
The <a href="https://www.ipso-alliance.org/technical-information/getting-started-with-smart-objects">Internet Protocol Smart Objects (ISPO)</a>
is fairly new, with the release of "Starter Pack 1.0" in September 2014, so it is just beginning to be adopted.
While reviewing the code for several of the first implementations, I was struck at how much of the same functionality was
already present in the work I have been doing on <a href="/news/2015/02/06/smart-devicetrees.html">Device Tree and Smart Device Trees</a>.
So, I think it's time that we introduced the Internet Protocol Smart Objects (ISPO) to Device Trees,
because I have a feeling they are going to get along really well with each other. 
</p>
<p>
<h3>Why employ the Device Tree?</h3>
Because the information that an embedded system needs to create a <a href="https://www.ipso-alliance.org/technical-information/getting-started-with-smart-objects">Internet Protocol Smart Objects (ISPO)</a> directory of "Smart Objects" is already contained within the 
<a href="/news/2015/02/06/smart-devicetrees.html">Device Tree</a>, and can be retrieved using the existing Device Tree parsers.
Unfortunately, most of the (early) IPSO examples that I have seen to date, duplicate this meta-data, and so the developer would need to
maintain it within two (2) separate areas of code for an IoT device.
</p>
<p>
In some of the next articles, I'll describe some methods to leverage the meta-data contained within the 
<a href="/news/2015/02/06/smart-devicetrees.html">Device Tree</a>, and to use that data to automatically generate
the <a href="https://www.ipso-alliance.org/technical-information/getting-started-with-smart-objects">Internet Protocol Smart Objects (ISPO)</a> directory of "Smart Objects". Stay tuned...
</p>
<p>   
<h2>References, Footnotes, and more...</h2>
<ol>
<li><a href="https://events.linuxfoundation.org/sites/events/files/slides/petazzoni-device-tree-dummies.pdf">Device Tree for Dummies - Thomas Petroni</a></li>
<li><a href="https://learn.adafruit.com/introduction-to-the-beaglebone-black-device-tree">BeagleBlack Device Tree Tutorial - Adafruit</a></li>
<li><a href="https://xillybus.com/tutorials/device-tree-zynq-1">Xilinx Device Tree Tutorial - Xillybus</a></li>
<li><a href="https://xillybus.com/tutorials/device-tree-altera-soc-cyclone">Altera Device Tree Tutorial - Xillybus</a></li>
<li><a href="https://blueprints.launchpad.net/ubuntu/+spec/mobile-lucid-arm-device-tree-support">ARM Device Tree Support - Ubuntu</a></li>
<li><a href="https://www.alterawiki.com/wiki/Sopc2dts">Altera Device Tree Support - Altera</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/devicetree/bindings/">Index of Device Tree Bindings - kernal.org</a></li>
<li><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/plain/Documentation/devicetree/bindings/graph.txt">Device Tree Graphing - kernal.org</a></li>
<li><a href="https://packages.debian.org/wheezy/libfdt-dev">libfdt - manipulating FDT Blobs - David Gibson</a></li>
<li><a href="https://www.informit.com/articles/article.aspx?p=1647051&seqNum=5">Linux Bootloaders - informit.com</a></li>
<li><a href="https://haifux.org/lectures/288/haifux-devicetree.pdf">Device Tree PnP - Eli Billauer</a></li>
<li><a href="https://lkml.org/lkml/2013/1/7/366">Device Tree Overlay Manager - Pantelis Antoniou</a></li>
<li><a href="https://lkml.org/lkml/2012/11/5/615">Device Tree Overlay Proposal - Grant Likely</a></li>
<li><a href="https://github.com/cdsteinkuehler/beaglebone-universal-io">BeagleBlack Univeral I/O - cdsteinkuehler</a></li>
<li><a href="https://kilobaser.com/blog/2014-07-28-beaglebone-black-devicetreeoverlay-generator#dtogenerator">BeagleBlack Device Tree Overlay Generator - Kilobaser</a></li>
<li><a href="https://derekmolloy.ie/gpios-on-the-beaglebone-black-using-device-tree-overlays/">GPIOs on the Beaglebone Black using the Device Tree Overlays- derek molloy</a></li>
<li><a href="https://elinux.org/images/f/f2/Supporting_200_Different_Expansionboards_The_Broken_Promise_of_Devicetree.pdf">Supporting 200 Different Expansion Boards -  elinux.org</a></li>
<li><a href="https://events.linuxfoundation.org/sites/events/files/slides/presentation_3.pdf">DT, The Disaster so Far - Mark Rutland</a></li>
<li><a href="https://elinux.org/images/5/5c/ELCE2013_-_DT_War.pdf">Board File to Device Tree Migration - Pantelis Antoniou</a></li>
<li><a href="https://lwn.net/Articles/616859/">Device Tree Overlays - Jonathon Corbet</a></li>
</ol>
</p>

</div>
      <footer>
        <a rel="full-article" href="/news/2015/05/21/devicetree-smart-objects.html"></a>
      </footer>
    </article>
  
    
    <article>
      <header>
        <h1 class="entry-title"><a href="/news/2015/02/09/devicetree-discussions.html">Device Tree Discussions</a></h1>
        
          <p class="meta">
            February 09, 2015
          </p>
        
      </header>
      <div class="entry-content">
      
      
      

<blockquote>
	<p>A new word is like a fresh seed sown on the ground of the discussion.</p>
	<p>&mdash;Ludwig Wittgenstein</p>
</blockquote>

    <p>
There has been considerable progress in the just the past few years with implementing the
<a href="https://www.devicetree.org/">Device Tree</a> format on embedded platforms, 
particlarly in the ARM portion of the Linux Kernal. It has been an interesting an interesting
time with all the growth and changes, but a little hard to locate all the different efforts underway.
I've been working to collect what I can find, and index some of the topics under discussion. 
</p>
<!-- more -->
<p>
</p>
<p>
<h2><a href="https://dir.gmane.org/gmane.comp.devicetree.spec">Device Tree Specification Mailing List</a></h2>
<iframe src="https://blog.gmane.org/recent.php?group=gmane.comp.devicetree.spec&type=topics&content=subject,date&td.author.background=green&
td.author.color=white&table.border=1px+solid+black&td.background=grey" width=680px height=80px ></iframe>
</p>
<p>
<h2><a href="https://dir.gmane.org/gmane.comp.devicetree.compiler">Device Tree Compiler Mailing List</a></h2>
<iframe src="https://blog.gmane.org/recent.php?group=gmane.comp.devicetree.compiler&type=topics&content=subject,date&td.author.background=green&
td.author.color=white&table.border=1px+solid+black&td.background=grey" width=680px height=200px ></iframe>
</p>
<p>
<h2><a href="https://dir.gmane.org/gmane.linux.drivers.devicetree">Linux Drivers Device Tree Mailing List</a></h2>
<iframe src="https://blog.gmane.org/recent.php?group=gmane.linux.drivers.devicetree&type=topics&content=subject,date&td.author.background=green&
td.author.color=white&table.border=1px+solid+black&td.background=grey" width=680px height=200px ></iframe>
</p>
<p>   
<h2>References, Footnotes, and more...</h2>
<ol>
<li><a href="https://events.linuxfoundation.org/sites/events/files/slides/petazzoni-device-tree-dummies.pdf">Device Tree for Dummies - Thomas Petroni</a></li>
<li><a href="https://learn.adafruit.com/introduction-to-the-beaglebone-black-device-tree">BeagleBlack Device Tree Tutorial - Adafruit</a></li>
<li><a href="https://xillybus.com/tutorials/device-tree-zynq-1">Xilinx Device Tree Tutorial - Xillybus</a></li>
<li><a href="https://xillybus.com/tutorials/device-tree-altera-soc-cyclone">Altera Device Tree Tutorial - Xillybus</a></li>
<li><a href="https://blueprints.launchpad.net/ubuntu/+spec/mobile-lucid-arm-device-tree-support">ARM Device Tree Support - Ubuntu</a></li>
<li><a href="https://www.alterawiki.com/wiki/Sopc2dts">Altera Device Tree Support - Altera</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/devicetree/bindings/">Index of Device Tree Bindings - kernal.org</a></li>
<li><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/plain/Documentation/devicetree/bindings/graph.txt">Device Tree Graphing - kernal.org</a></li>
<li><a href="https://packages.debian.org/wheezy/libfdt-dev">libfdt - manipulating FDT Blobs - David Gibson</a></li>
<li><a href="https://www.informit.com/articles/article.aspx?p=1647051&seqNum=5">Linux Bootloaders - informit.com</a></li>
<li><a href="https://haifux.org/lectures/288/haifux-devicetree.pdf">Device Tree PnP - Eli Billauer</a></li>
<li><a href="https://lkml.org/lkml/2013/1/7/366">Device Tree Overlay Manager - Pantelis Antoniou</a></li>
<li><a href="https://lkml.org/lkml/2012/11/5/615">Device Tree Overlay Proposal - Grant Likely</a></li>
<li><a href="https://github.com/cdsteinkuehler/beaglebone-universal-io">BeagleBlack Univeral I/O - cdsteinkuehler</a></li>
<li><a href="https://kilobaser.com/blog/2014-07-28-beaglebone-black-devicetreeoverlay-generator#dtogenerator">BeagleBlack Device Tree Overlay Generator - Kilobaser</a></li>
<li><a href="https://derekmolloy.ie/gpios-on-the-beaglebone-black-using-device-tree-overlays/">GPIOs on the Beaglebone Black using the Device Tree Overlays- derek molloy</a></li>
<li><a href="https://elinux.org/images/f/f2/Supporting_200_Different_Expansionboards_The_Broken_Promise_of_Devicetree.pdf">Supporting 200 Different Expansion Boards -  elinux.org</a></li>
<li><a href="https://events.linuxfoundation.org/sites/events/files/slides/presentation_3.pdf">DT, The Disaster so Far - Mark Rutland</a></li>
<li><a href="https://elinux.org/images/5/5c/ELCE2013_-_DT_War.pdf">Board File to Device Tree Migration - Pantelis Antoniou</a></li>
<li><a href="https://lwn.net/Articles/616859/">Device Tree Overlays - Jonathon Corbet</a></li>
</ol>
</p>

</div>
      <footer>
        <a rel="full-article" href="/news/2015/02/09/devicetree-discussions.html"></a>
      </footer>
    </article>
  
    
    <article>
      <header>
        <h1 class="entry-title"><a href="/news/2015/02/06/smart-devicetrees.html">Smart Devicetrees</a></h1>
        
          <p class="meta">
            February 06, 2015
          </p>
        
      </header>
      <div class="entry-content">
      
      
      

<blockquote>
	<p>A smart man makes a mistake, learns from it, and never makes that mistake again. But a wise man finds a smart man and learns from him how to avoid the mistake altogether.</p>
	<p>&mdash;Roy H. Williams</p>
</blockquote>

    <p>
Lately, I've been working on automatic discovery and configuration of devices and peripherals, using 
<a href="https://www.patternagents.com/news/2015/01/25/the-blob.html">Binary Level Objects</a>, like the
<a href="https://www.intel.com/content/www/us/en/servers/ipmi/information-storage-definition-rev-1-2.html">IPMI FRU</a>, the
<a href="https://www.devicetree.org/Device_Tree_Usage">Devicetree</a> and
<a href="https://www.devicetree.org/Device_Tree_Usage">Devicetree Overlay</a> formats.
Typically these have been implemented using just a "dumb" storage device,
like an <a href="https://en.wikipedia.org/wiki/EEPROM">EEPROM</a>, or an 
<a href="https://en.wikipedia.org/wiki/Secure_Digital">SDcard</a>, or perhaps a 
<a href="https://www.st.com/web/en/catalog/mmc/FM76/CL1766/SC1412/SS1812">Dynamic NFC/RFID tag</a>.
So, what then, do I mean by a "Smart" Devicetree?
<br><br>
</p>
<!-- more -->
<p>
<h2>Low Cost Microcontrollers</h2>
A few years ago, we were all abuzz about the "$1" ARM Cortex devices like the Cortex M-3, 
and later, the Cortex M-0 devices.
Hat's off to <a href="https://www.arm.com/">ARM Ltd.</a> for making 32-bit microcontrollers ubiquitous.
By now (2015), the cost of simple microcontrollers are more about the amount of flash memory
and the features included, than the microcontroller itself. These days I can usually find a 
low feature, low pin count, microcontroller for little more than the cost of a "dumb" storage device.
Additionally, the smartphone and mobile handset market have led the push to smaller packages, 
and lower power microcontrollers, in order to increase the battery powered run time. So the 
threshold for adding "intelligence" (i.e. a microcontroller) to solving hardware design problems
has gotten very low indeed.
</p>
<p>
<h2>Common Data Structures</h2>
Regardless of what kind of microcontroller and development environment you choose for your products,
 you'll soon realize that you need to keep track of a lot of <a href="https://en.wikipedia.org/wiki/Metadata"><i>metadata</i></a> 
which most development enviroments will leave up to you, the user. I'm talking about the kinds of data you need regardless of
what kind of product you are building, and what kind of firmware/software you are using. 
How do you keep track of things
like Serial Numbers, Version Numbers, MAC ID's, Interface Addresses, etc. in a uniform way?
Where do you keep them in your firmware (program)and how do you keep them current
without having to change the firmware itself?
From a complex Drone design to a more simple toaster oven, wouldn't it be good
if we could handle all that <a href="https://en.wikipedia.org/wiki/Metadata">metadata</a>
in a more simple and consistant way?     
</p>
<h2>Common Interfaces</h2>
<img class="illo" src="/news/devicetree/smart-dev-tree.png" alt="Example Low Cost Microcontroller" title="Example Low Cost Microcontroller"/>
Most of the low cost microcontrollers today have a good mix of common interfaces, like 
<a href="https://en.wikipedia.org/wiki/I%C2%B2C">I2C</a>, 
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus">SPI</a>, and 
<a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter">UARTs</a>.
And most vendors also include some simple emulation functions, that allow you to reserve an
area of the microcontroller's flash memory to emulate a "dumb" storage device using those
interfaces. In other words, if you use an I2C EEPROM emulation function on most microcontrollers,
then to the outside world connecting to your microcontroller, your microcontroller looks exactly 
like a "dumb" I2C EEPROM. The same concept applies if you bind one of your SPI Slave controllers 
to a SPI EEPROM emulator function, then to the outside world, your microcontroller would 
look just like a "dumb" SPI EEPROM.  
</p>
<p>
<h2>Devicetree Flash Mapping</h2>
Of course, "under the hood", this solution is not "dumb" at all. 
When you utilize an I2C or SPI EEPROM emulation function, 
you generally pass a pointer to the flash memory area that you want reserved 
for the EEPROM memory emulation. If we are not going to do much else with 
microcontroller we might even reserve the majority of the microcontrollers flash memory.
Now, imagine for a moment that reserved flash memory area is used to hold the 
Flattened Devicetree "BLOB" of binary data, perhaps for an expansion board.
What we have now, is a "Smart Devicetree". We can even access that
Devicetree from two different interfaces, namely 
<a href="https://en.wikipedia.org/wiki/I%C2%B2C">I2C</a>, and 
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus">SPI</a>
at the same time. In my 
<a href="https://www.patternagents.com/news/2015/02/02/devicetree-on-modbus.html">last article</a>
I demonstrated how to map the Devicetree onto a <a href="https://en.wikipedia.org/wiki/Modbus">Modbus</a> 
RTU using a UART interface. I've successfully employed these techniques in several customer designs.
</p>
<p>
<h2>Adding Some Intelligence</h2>
You'll notice that I put an "Internal Temperature" block in the above microcontroller block
diagram, as most microcontrollers have a junction temperature measurement that can be used
to read the internal temperature of the device. Now, imagine for a moment, that the microcontroller
takes a initial temperature measurement when it boots, and maintains a running average temperature at boot.
So, what happens if we store that as a property into the Flattened <a href="https://www.devicetree.org/">Devicetree</a> (BLOB)?
Well, now we have a <i>Smart Devicetree</i>.
</p>
<p>
<h2>Summary</h2>
Adding the Devicetree data structure to an embedded micrcontroller design is 
pretty straightforward and simple, and enables the automatic discovery and configuration of 
a variety of devices and peripherals; and that is just the beginning of what we can do with a
<i>Smart Devicetree</i>. 
</p>
<p>   
<h2>References, Footnotes, and more...</h2>
<ol>
<li><a href="https://www.modbus.org/specs.php">Modbus Specifications</a></li>
<li><a href="https://events.linuxfoundation.org/sites/events/files/slides/petazzoni-device-tree-dummies.pdf">Devicetree for Dummies - Thomas Petroni</a></li>
<li><a href="https://learn.adafruit.com/introduction-to-the-beaglebone-black-device-tree">BeagleBlack Devicetree Tutorial - Adafruit</a></li>
<li><a href="https://xillybus.com/tutorials/device-tree-zynq-1">Xilinx Devicetree Tutorial - Xillybus</a></li>
<li><a href="https://xillybus.com/tutorials/device-tree-altera-soc-cyclone">Altera Devicetree Tutorial - Xillybus</a></li>
<li><a href="https://blueprints.launchpad.net/ubuntu/+spec/mobile-lucid-arm-device-tree-support">ARM Devicetree Support - Ubuntu</a></li>
<li><a href="https://www.alterawiki.com/wiki/Sopc2dts">Altera Devicetree Support - Altera</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/devicetree/bindings/">Index of Devicetree Bindings - kernal.org</a></li>
<li><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/plain/Documentation/devicetree/bindings/graph.txt">Devicetree Graphing - kernal.org</a></li>
<li><a href="https://packages.debian.org/wheezy/libfdt-dev">libfdt - manipulating FDT Blobs - David Gibson</a></li>
<li><a href="https://www.informit.com/articles/article.aspx?p=1647051&seqNum=5">Linux Bootloaders - informit.com</a></li>
<li><a href="https://haifux.org/lectures/288/haifux-devicetree.pdf">Devicetree PnP - Eli Billauer</a></li>
<li><a href="https://lkml.org/lkml/2013/1/7/366">Devicetree Overlay Manager - Pantelis Antoniou</a></li>
<li><a href="https://lkml.org/lkml/2012/11/5/615">Devicetree Overlay Proposal - Grant Likely</a></li>
<li><a href="https://github.com/cdsteinkuehler/beaglebone-universal-io">BeagleBlack Univeral I/O - cdsteinkuehler</a></li>
<li><a href="https://kilobaser.com/blog/2014-07-28-beaglebone-black-devicetreeoverlay-generator#dtogenerator">BeagleBlack Devicetree Overlay Generator - Kilobaser</a></li>
<li><a href="https://derekmolloy.ie/gpios-on-the-beaglebone-black-using-device-tree-overlays/">GPIOs on the Beaglebone Black using the Devicetree Overlays- derek molloy</a></li>
<li><a href="https://elinux.org/images/f/f2/Supporting_200_Different_Expansionboards_The_Broken_Promise_of_Devicetree.pdf">Supporting 200 Different Expansion Boards -  elinux.org</a></li>
<li><a href="https://events.linuxfoundation.org/sites/events/files/slides/presentation_3.pdf">DT, The Disaster so Far - Mark Rutland</a></li>
<li><a href="https://elinux.org/images/5/5c/ELCE2013_-_DT_War.pdf">Board File to Devicetree Migration - Pantelis Antoniou</a></li>
<li><a href="https://lwn.net/Articles/616859/">Devicetree Overlays - Jonathon Corbet</a></li>
</ol>
</p>

</div>
      <footer>
        <a rel="full-article" href="/news/2015/02/06/smart-devicetrees.html"></a>
      </footer>
    </article>
  
    
    <article>
      <header>
        <h1 class="entry-title"><a href="/news/2015/02/02/devicetree-on-modbus.html">Device Tree on Modbus</a></h1>
        
          <p class="meta">
            February 02, 2015
          </p>
        
      </header>
      <div class="entry-content">
      
      
      

<blockquote>
	<p>Education is the most powerful weapon you can use to change the world.</p>
	<p>&mdash;Nelson Mandela</p>
</blockquote>

    <p>
Unless you've been living under a rock since the late '70's, you've probably heard about 
<a href="https://en.wikipedia.org/wiki/Modbus">Modbus</a>, the communications protocol used
for a wide variety of industrial systems, from 
<a href="https://www.modbus.org/companies.php">sensors</a> to 
<a href="https://en.wikipedia.org/wiki/Programmable_logic_controller">programmable logic controllers(PLCs)</a>.
<a href="https://en.wikipedia.org/wiki/Modbus">Modbus</a> can be found in most factories and automated assembly lines. 
<a href="https://en.wikipedia.org/wiki/Modbus">Modbus</a> devices can be quite complicated; but what if we used
an embedded <a href="https://www.devicetree.org/Device_Tree_Usage">Device Tree</a> to describe them? <br>
That would enable the automatic discovery and configuration <br>
of <a href="https://en.wikipedia.org/wiki/Modbus">Modbus</a> devices and peripherals, wouldn't it?   
</p>
<!-- more -->
<p>
<h2>Modbus</h2>
<a href="https://en.wikipedia.org/wiki/Modbus">Modbus</a>
 is a communications protocol developed by Schneider Electric (nee Modicon) in the 1970's.
Simple to implement, and robust in operation, it is used by a wide variety of manufacturers.
<a href="https://en.wikipedia.org/wiki/Modbus">Modbus</a> is often associated with 
<a href="https://en.wikipedia.org/wiki/SCADA">supervisory and data acquisition (SCADA)</a> systems for process control.
Manufacturing, power generation, refining, waste treatment plants, you name it, and you are likely to find 
<a href="https://en.wikipedia.org/wiki/Modbus">Modbus</a> devices installed there.
</p>
<p>
<h2>Modbus Addressing</h2>
<img  class="illo" src="/news/modbus/modbus-address-map.png" alt="Modbus Address Map" title="Modbus Address Map"/></a>
<a href="https://en.wikipedia.org/wiki/Modbus">Modbus</a> has four (4) independent address spaces,
and utilizes different
<a href="https://en.wikipedia.org/wiki/Modbus#Supported_function_codes">Function Codes</a>, or commands,
to access each one of those address spaces. 
The age of Modbus starts to show when you look at the name of the first address space, namely "Coils".
Yup, "Coils", that's what they used to call bits back in the electromechanical dark ages,
when a bit was literally a single coil turning on or off! The second address space is known as the "Discrete Inputs" space,
and it is typically used to read to read the state of individual switches on a device.
The largest address space is called the "Holding Register" address space, and it is typically used for device control registers.
Lastly, is the "Input Register" address space, typically used for reading multibit values, like an Analog-to-Digital
converter output. 
<a href="https://en.wikipedia.org/wiki/Modbus">Modbus</a> has decently large address spaces, which is one of the 
reasons it has survived as a standard for over forty(40) years, it was designed to grow as needed.
</p>
<p>
&nbsp;
</p>
<p>
<h2>Modbus Addressing with Device Tree</h2>
<img class="illo" src="/news/modbus/modbus-device-tree.png" alt="Modbus Device Tree" title="Modbus Device Tree"/></a>
One technique that I have successfully used in the past,
is locating a <a href="https://www.patternagents.com/news/2015/01/25/the-blob.html">Binary Level OBject (i.e. BLOB)</a>
within one of the address spaces of the Modbus Device, typically in the 
<a href="https://www.csimn.com/CSI_pages/Modbus101.html#mb101_regtypes">Holding Register Address Space</a>
starting at address offset zero (0x0000). I have done this many times in the past using an
<a href="https://www.intel.com/content/www/us/en/servers/ipmi/information-storage-definition-rev-1-2.html">IPMI FRU</a> : (Intelligent Peripheral Management Interface - Field Replaceable Unit) data structure definition, but it is just as simple to implement using the 
<a href="https://www.devicetree.org/Device_Tree_Usage">Device Tree</a> data structure definition.
At a minimum, the <a href="https://www.devicetree.org/Device_Tree_Usage">Device Tree</a> data structure
can identify the make and model number of the Modbus device. However, using 
<a href="https://www.linux.com/news/embedded-mobile/mobile-linux/785882-device-tree-overlay-support-lands-upstream">Device Tree Overlays</a>
with more detailed device and register descriptions, it is feasible to embed the entire description of the Modbus device
within the <a href="https://www.patternagents.com/news/2015/01/25/the-blob.html">Binary Level OBject (i.e. BLOB)</a>.
</p>
<p>
In the past <a href="https://en.wikipedia.org/wiki/Modbus">Modbus</a> devices have usually required a very
specific driver for each different make and model number of device, with little or no automatic discovery
and configuration of <a href="https://en.wikipedia.org/wiki/Modbus">Modbus</a> devices being possible.
Technicians would usually need to add each <a href="https://en.wikipedia.org/wiki/Modbus">Modbus</a> device to
their <a href="https://en.wikipedia.org/wiki/SCADA">supervisory and data acquisition (SCADA)</a> systems manually.
</p>
<p>
<h2>Summary</h2>
Adding the Device Tree data structure to <a href="https://en.wikipedia.org/wiki/Modbus">Modbus</a> devices is 
pretty straightforward and simple, and enables the automatic discovery and configuration of 
<a href="https://en.wikipedia.org/wiki/Modbus">Modbus</a> devices and peripherals. 
</p>
<p>   
<h2>References, Footnotes, and more...</h2>
<ol>
<li><a href="https://www.modbus.org/specs.php">Modbus Specifications</a></li>
<li><a href="https://events.linuxfoundation.org/sites/events/files/slides/petazzoni-device-tree-dummies.pdf">Device Tree for Dummies - Thomas Petroni</a></li>
<li><a href="https://learn.adafruit.com/introduction-to-the-beaglebone-black-device-tree">BeagleBlack Device Tree Tutorial - Adafruit</a></li>
<li><a href="https://xillybus.com/tutorials/device-tree-zynq-1">Xilinx Device Tree Tutorial - Xillybus</a></li>
<li><a href="https://xillybus.com/tutorials/device-tree-altera-soc-cyclone">Altera Device Tree Tutorial - Xillybus</a></li>
<li><a href="https://blueprints.launchpad.net/ubuntu/+spec/mobile-lucid-arm-device-tree-support">ARM Device Tree Support - Ubuntu</a></li>
<li><a href="https://www.alterawiki.com/wiki/Sopc2dts">Altera Device Tree Support - Altera</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/devicetree/bindings/">Index of Device Tree Bindings - kernal.org</a></li>
<li><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/plain/Documentation/devicetree/bindings/graph.txt">Device Tree Graphing - kernal.org</a></li>
<li><a href="https://packages.debian.org/wheezy/libfdt-dev">libfdt - manipulating FDT Blobs - David Gibson</a></li>
<li><a href="https://www.informit.com/articles/article.aspx?p=1647051&seqNum=5">Linux Bootloaders - informit.com</a></li>
<li><a href="https://haifux.org/lectures/288/haifux-devicetree.pdf">Device Tree PnP - Eli Billauer</a></li>
<li><a href="https://lkml.org/lkml/2013/1/7/366">Device Tree Overlay Manager - Pantelis Antoniou</a></li>
<li><a href="https://lkml.org/lkml/2012/11/5/615">Device Tree Overlay Proposal - Grant Likely</a></li>
<li><a href="https://github.com/cdsteinkuehler/beaglebone-universal-io">BeagleBlack Univeral I/O - cdsteinkuehler</a></li>
<li><a href="https://kilobaser.com/blog/2014-07-28-beaglebone-black-devicetreeoverlay-generator#dtogenerator">BeagleBlack Device Tree Overlay Generator - Kilobaser</a></li>
<li><a href="https://derekmolloy.ie/gpios-on-the-beaglebone-black-using-device-tree-overlays/">GPIOs on the Beaglebone Black using the Device Tree Overlays- derek molloy</a></li>
<li><a href="https://elinux.org/images/f/f2/Supporting_200_Different_Expansionboards_The_Broken_Promise_of_Devicetree.pdf">Supporting 200 Different Expansion Boards -  elinux.org</a></li>
<li><a href="https://events.linuxfoundation.org/sites/events/files/slides/presentation_3.pdf">DT, The Disaster so Far - Mark Rutland</a></li>
<li><a href="https://elinux.org/images/5/5c/ELCE2013_-_DT_War.pdf">Board File to Device Tree Migration - Pantelis Antoniou</a></li>
<li><a href="https://lwn.net/Articles/616859/">Device Tree Overlays - Jonathon Corbet</a></li>
</ol>
</p>

</div>
      <footer>
        <a rel="full-article" href="/news/2015/02/02/devicetree-on-modbus.html"></a>
      </footer>
    </article>
  
    
    <article>
      <header>
        <h1 class="entry-title"><a href="/news/2015/02/01/devicetree-lifecycle.html">Device Tree and Product Life Cycles</a></h1>
        
          <p class="meta">
            February 01, 2015
          </p>
        
      </header>
      <div class="entry-content">
      
      
      

<blockquote>
	<p>Why do they always want to do it the hard way?</p>
	<p>&mdash;Wile E. Coyote, Genius</p>
</blockquote>

    <p>Imagine that <a hrel="https://en.wikipedia.org/wiki/Wile_E._Coyote_and_The_Road_Runner">Wile E. Coyote</a> has just finished watching<BR> 
<a href="https://www.pbs.org/wgbh/nova/military/rise-of-the-drones.html">"Rise of the Drones"</a> on PBS, and he has had a 
<a href="https://en.wikipedia.org/wiki/Eureka">"Eureka!"</a> moment. 
He immediately dials <a href="https://en.wikipedia.org/wiki/Acme_Corporation">Acme Corporation</a> and
orders several dozen <a href="https://terminator.wikia.com/wiki/HK-Drone">T-4 Aerial Drones</a>. As the new manager of 
<a href="https://en.wikipedia.org/wiki/Acme_Corporation">Acme Corporation</a>, you realize that 
<a hrel="https://en.wikipedia.org/wiki/Wile_E._Coyote_and_The_Road_Runner">Wile E. Coyote</a> will in all likelyhood <b><i>crash</i></b>
the majority of them, and you will need a good way to track warranty claims and product repairs; <br>
as he seems to have an unlimited line-of-credit, and he has also <br>
purchased the <b><i>platinum service plan</i></b> with every one of those Drones.
</p>
<!-- more -->
<p>
<h2>Manufacturing Traceability</h2>
<img class="illo" src="/news/devicetree/quad-px4.png" alt="PX4 Drone" title="PX4 Drone"/>
A Drone can be a pretty complex piece of gear, with a lot of parts and subsystems.
<a href="https://en.wikipedia.org/wiki/Traceability">Traceability</a> is the ability to verify the history, location, or application
of an item by means of documented recorded identification <a href="https://go.usa.gov/BP6">[1]</a>.
This can be very important with components, or sensors that have a limited life time,
typically measured in hours of use. As we repair and replace crashed Drones, we'll want a way
to keep track of the major parts and subsystems, like the 
<a href="https://www.tomshardware.com/reviews/multi-rotor-quadcopter-fpv,3828-4.html">Airframe</a>, 
<a href="https://beagleboard.org/project/BeagleDrone/">main computer</a>, 
<a href="https://pixhawk.org/modules/pixhawk">flight controller</a>, 
<a href="https://www.tomshardware.com/reviews/multi-rotor-quadcopter-fpv,3828-6.html">motor controllers</a>, and the 
<a href="https://www.tomshardware.com/reviews/multi-rotor-quadcopter-fpv,3828-5.html">rotors</a>.
</p>
<p>
One of the attributes that I like about the 
<a href="https://www.intel.com/content/www/us/en/servers/ipmi/information-storage-definition-rev-1-2.html">IPMI FRU</a> 
format for storing product information, <br>
is it's support of manufacturing traceability properties, such as :
<ul>
<li>product-model-name : "T-4 Aerial Drone"</li>
<li>product-mfg-name : ACME Corporation</li>
<li>product-mfg-date : (Univeral Time Code)</li>
<li>product-mfg-loc : (GPS coordinates)</li>
<li>product-asset-num : (ASSET TAG)</li>
<li>product-serial-num : (SERIAL NUMBER)/(UUID)</li>
</ul>
So, can we add these kinds of manufacturing traceability properties to the Device Tree?
It would seem to be exactly what we need to track the metadata for each subsystem, and follow it through it's whole lifecycle.
</p>
<p>
<h2>Drone Product Tree</h2>
Let's take a typical quadcopter type drone design, using a central mounting plate for the batteries and main electronics,
with four (4) or more motor arms to hold each of the motors and rotors.
If we were to outline a simplified version of the part and subsystem heirarchy, it might look something like this : 
</p>
<p>
<img src="/news/devicetree/quad-tree.png" alt="Example Drone Tree Nodes" title="Example Drone Tree Nodes"/>
</p>
<p>
<h2>Dynamic NFC/RFID Tags</h2>
<a href="https://www.st.com/web/en/catalog/mmc/FM76/CL1766/SC1412/SS1812">
<img class="illo" src="/news/devicetree/rfid-tag-small.png" alt="RFID Asset Tag" title="RFID Asset Tag"/></a>
Now, because you are the best manager that <a href="https://en.wikipedia.org/wiki/Acme_Corporation">Acme Corporation</a> has had
in quite a while, you have decided to use a 
<a href="https://www.st.com/web/en/catalog/mmc/FM76/CL1766/SC1412/SS1812">Dynamic NFC/RFID tag</a>
at the root of your product tree, namely on the Chassis (Air Frame) itself. 
This allows your service technicians to use an RFID reader/writer wand,
or their smartphone to interogate each Drone as it is tested or returned, and get the complete list of subassemblies,
their serial numbers, and dates of manufacture. 
</p>
<p>
The <a href="https://www.st.com/web/en/catalog/mmc/FM76/CL1766/SC1412/SS1812">Dynamic NFC/RFID tag</a> 
can be read/written either using the RF interface,
or from within the product itself - using the I2C interface to the tag.
This dual interface is important, as it allows the main computer to update the 
<a href="https://www.st.com/web/en/catalog/mmc/FM76/CL1766/SC1412/SS1812">Dynamic NFC/RFID tag</a> as well.
</p>
<p>

</div>
      <footer>
        <a rel="full-article" href="/news/2015/02/01/devicetree-lifecycle.html"></a>
      </footer>
    </article>
  
    
    <article>
      <header>
        <h1 class="entry-title"><a href="/news/2015/01/29/devicetree-overlays.html">Device Tree Overlays</a></h1>
        
          <p class="meta">
            January 29, 2015
          </p>
        
      </header>
      <div class="entry-content">
      
      
      

<blockquote>
	<p>If a tree dies, plant another in its place.</p>
	<p>&mdash;Carl Linnaeus</p>
</blockquote>

    <p>In my <a href="https://www.patternagents.com/news/2015/01/28/devicetree-overview.html">last article</a>, 
I gave a general overview of the <a href="https://www.devicetree.org/">Device Tree</a> format,
and some basics on how it is being used for automatically configuring the hardware of embedded computing platforms like the Beaglebone Black,
Xilinx Zynq, and many other System-on-Chip (SOC) devices.  
<a href="https://www.linux.com/news/embedded-mobile/mobile-linux/785882-device-tree-overlay-support-lands-upstream">Device Tree Overlays</a>,
originated by Pantelis Antoniou are now being used to support add-on devices and expansion boards,
allowing automatic discovery and automatic configuration on several computing platforms.
In this article, I'll discuss the 
<a href="https://www.linux.com/news/embedded-mobile/mobile-linux/785882-device-tree-overlay-support-lands-upstream">Device Tree Overlay</a> 
and why it is getting adopted for even more computing platforms.  
</p>
<!-- more -->
<p>
The <a href="https://www.devicetree.org/">DeviceTree</a> format has been employed on several Linux based computing platforms,
such as the PowerPC, or Power Architecture for several years now. However, add-on and expansion boards typically had either
no automatic configuration support, or used other description structures like the 
<a href="https://www.intel.com/content/www/us/en/servers/ipmi/information-storage-definition-rev-1-2.html">IPMI FRU</a> blob, 
or the <a href="https://standards.ieee.org/findstds/standard/1451.4-2004.html">TEDS</a> blob (for sensors). 
However, as hardware becomes more maleable, using Field Programmable Gate Arrays, and Programmable System-on-Chip devices,
the hardware begins to "soften", and to resemble software. "Hardware" said Pantelis Antoniou at LinuxCon2014, "is software now".
So the concept of a static and unchanging <a href="https://www.devicetree.org/">Device Tree</a> wasn't keeping pace with the
new programmable hardware paradigms, and Pantelis originated the idea of a 
<a href="https://www.linux.com/news/embedded-mobile/mobile-linux/785882-device-tree-overlay-support-lands-upstream">Device Tree Overlay</a>
that could be dynamically loaded and unloaded to change hardware configurations. It has taken some time (and a lot of work by Pantelis and others)
to make all the Linux kernal and Device Tree Compiler changes required, 
but now, most of their work has been merged into the 3.17 Linux Kernal.   
</p>
<p>
<a href="https://www.liquidware.com/shop/show/BB-ULT/Ultimate+Beagle+Gadget+Pack"><img class="illo" src="/news/sff/beaglebone-stack.png" alt="Liquidware Beaglebone Stack" title="Liquidware Beaglebone Stack"/></a>
Consider a typical development situation, using something like a Beaglebone Black,
where you have a main CPU/SoC board, and several expansion boards (i.e. "Capes") attached,
similar to the picture to the right. For the sake of discussion, let's say that Cape #1 communicates with the
main CPU/SoC via a serial UART interface, Cape #2 and #3 communicate via a SPI interface with separate
Chip Selects for each Cape, and that Cape #3 communicates using General Purpose I/O (GPIO),
and the main CPU/SoC Analog-to-Digital converter (ADC). In order to support the <a href="https://www.devicetree.org/">Device Tree</a> 
configuration, each board/Shield will contain a small I2C EEPROM that will hold the <a href="https://www.devicetree.org/">Device Tree</a>
Flattened Device Tree data structures (i.e. the Overlays). This is a fairly common configuration, 
and it doesn't really matter WHAT the Capes are for this discussion, they could be peripherals 
like LCD displays, Wi-Fi Radios, Motor Controllers, Sensor Hubs, etc. We're interested here in
describing their interconnections, which can be represented by the block diagram below :
</p>
<p>
<img src="/news/devicetree/soc-block-diagram.png" alt="SoC Simplified Block Diagram" title="SoC Simplified Block Diagram"/>
</p>
<p>
As you can see in the above block diagram, the "orange" colored blocks represent the connections on the 
<a href="https://en.wikipedia.org/wiki/I%C2%B2C">I2C</a> bus that will be used to read the 
Flattened Device Tree data structures (i.e. the Overlays) for each expansion board (i.e. Cape/Shield/Plate),
in order to determine their make and model, and how they are interfaced and connected.
</p>
<p>
<h2>Device Tree Source Overlay</h2>
</p>
<p>
Alright, so let's look at what a Device Tree Source Overlay might look like for Cape #1,
which is connected via a serial port, namely UART0. For this example, we'll use the 
<a href="https://www.mouser.com/ProductDetail/CircuitCo/BB-BONE-SERL-03/?qs=%2fha2pyFadugh6wNMONnDuOjD7VMVGO9jXYY7ybHwRb1PtvVW33RwxXpt9lg9jBxJ">Circuit Co.
RS-232 Cape</a> as an example of a currently used Device Tree Overlay.
</p>
<p>
<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre></td><td class="code"><pre><span class="o">*</span>
 <span class="o">*</span> <span class="n">Copyright</span> <span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="mi">2013</span> <span class="n">CircuitCo</span>
 <span class="o">*</span>
 <span class="o">*</span> <span class="n">Virtual</span> <span class="n">cape</span> <span class="k">for</span> <span class="n">UART1</span> <span class="n">on</span> <span class="n">connector</span> <span class="n">pins</span> <span class="n">P9</span><span class="p">.</span><span class="mi">24</span> <span class="n">P9</span><span class="p">.</span><span class="mi">26</span>
 <span class="o">*</span>
 <span class="o">*</span> <span class="n">This</span> <span class="n">program</span> <span class="n">is</span> <span class="n">free</span> <span class="n">software</span><span class="p">;</span> <span class="n">you</span> <span class="n">can</span> <span class="n">redistribute</span> <span class="n">it</span> <span class="n">and</span><span class="o">/</span><span class="n">or</span> <span class="n">modify</span>
 <span class="o">*</span> <span class="n">it</span> <span class="n">under</span> <span class="n">the</span> <span class="n">terms</span> <span class="n">of</span> <span class="n">the</span> <span class="n">GNU</span> <span class="n">General</span> <span class="n">Public</span> <span class="n">License</span> <span class="n">version</span> <span class="mi">2</span> <span class="n">as</span>
 <span class="o">*</span> <span class="n">published</span> <span class="n">by</span> <span class="n">the</span> <span class="n">Free</span> <span class="n">Software</span> <span class="n">Foundation</span><span class="p">.</span>
 <span class="err">*/</span>
<span class="o">/</span><span class="n">dts</span><span class="o">-</span><span class="n">v1</span><span class="o">/</span><span class="p">;</span>
<span class="o">/</span><span class="n">plugin</span><span class="o">/</span><span class="p">;</span>
 
<span class="o">/</span> <span class="p">{</span>
   	<span class="n">compatible</span> <span class="o">=</span> <span class="s">"ti,beaglebone"</span><span class="p">,</span> <span class="s">"ti,beaglebone-black"</span><span class="p">;</span>
 
        <span class="cm">/* identification */</span>
        <span class="n">part</span><span class="o">-</span><span class="n">number</span> <span class="o">=</span> <span class="s">"BB-UART1"</span><span class="p">;</span>
        <span class="n">version</span> <span class="o">=</span> <span class="s">"00A0"</span><span class="p">;</span>
 
        <span class="cm">/* state the resources this cape uses */</span>
        <span class="n">exclusive</span><span class="o">-</span><span class="n">use</span> <span class="o">=</span>
                <span class="cm">/* the pin header uses */</span>
                <span class="s">"P9.24"</span><span class="p">,</span>        <span class="cm">/* uart1_txd */</span>
                <span class="s">"P9.26"</span><span class="p">,</span>        <span class="cm">/* uart1_rxd */</span>
                <span class="cm">/* the hardware ip uses */</span>
                <span class="s">"uart1"</span><span class="p">;</span>
 
	<span class="n">fragment</span><span class="err">@</span><span class="mi">0</span> <span class="p">{</span>
                <span class="n">target</span> <span class="o">=</span> <span class="o">&lt;&amp;</span><span class="n">am33xx_pinmux</span><span class="o">&gt;</span><span class="p">;</span>
                <span class="n">__overlay__</span> <span class="p">{</span>
                        <span class="n">bb_uart1_pins</span><span class="o">:</span> <span class="n">pinmux_bb_uart1_pins</span> <span class="p">{</span>
                                <span class="n">pinctrl</span><span class="o">-</span><span class="n">single</span><span class="p">,</span><span class="n">pins</span> <span class="o">=</span> <span class="o">&lt;</span>
					<span class="cm">/* P9.24 MODE0 OUTPUT (TXD) */</span>
					<span class="mh">0x184</span> <span class="mh">0x20</span>
					<span class="cm">/* P9.26 MODE0 INPUT  (RXD) */</span> 
					<span class="mh">0x180</span> <span class="mh">0x20</span> 
                                <span class="o">&gt;</span><span class="p">;</span>
                        <span class="p">};</span>
                <span class="p">};</span>
	<span class="p">};</span>
 
	<span class="n">fragment</span><span class="err">@</span><span class="mi">1</span> <span class="p">{</span>
                <span class="n">target</span> <span class="o">=</span> <span class="o">&lt;&amp;</span><span class="n">uart2</span><span class="o">&gt;</span><span class="p">;</span>	<span class="cm">/* really uart1 */</span>
                <span class="n">__overlay__</span> <span class="p">{</span>
                        <span class="n">status</span> <span class="o">=</span> <span class="s">"okay"</span><span class="p">;</span>
                        <span class="n">pinctrl</span><span class="o">-</span><span class="n">names</span> <span class="o">=</span> <span class="s">"default"</span><span class="p">;</span>
                        <span class="n">pinctrl</span><span class="o">-</span><span class="mi">0</span> <span class="o">=</span> <span class="o">&lt;&amp;</span><span class="n">bb_uart1_pins</span><span class="o">&gt;</span><span class="p">;</span>
                <span class="p">};</span>
        <span class="p">};</span>
<span class="p">};</span></pre></td></tr></tbody></table></code></pre></figure>
</p>
<p>
The first properties define our "compatible" properties, and the part number and version.
This is followed the "exclusive-use", which defines what resources we want to utilize exclusively.
Then comes the pin multiplexing definitions, and finally our "uart0" definition.
Once compiled, using the Device Tree Compiler, the resulting Flattened Device Tree binary overlay
can be written into the I2C EEPROM located on Cape #1 (or Shield #1, PiPlate #1, etc.). 
Don't worry too much if you don't follow all the exact syntax details yet, 
we'll cover more on these concepts in the detailed how-to articles for each specific platform. 
</p>
<p>
<h2>Automatic Device Discovery</h2>
After a reboot, the connections and interface to Cape #1 can be automatically discovered and configured.
How, you ask? Well, during the boot up sequence, the processor reads the Flattened Device Tree binary
from it's local EEPROM (or it's internal flash memory), and using the main Device Tree, configures it's
I2C controller (shown in "orange" in the above block diagram), and then starts to read the contents of
each of the remote EEPROMs, located on the expansion cards, one at a time, 
by expecting them to reside at the following addresses on the I2C bus.
</p>
<p>
<table border="2" spacing="2">
<tr>
<td>&nbsp; A2 &nbsp;</td>
<td>&nbsp; A1 &nbsp;</td>
<td>&nbsp; A0 &nbsp;</td>
<td>&nbsp; I2C Address &nbsp;</td>
<td>&nbsp; Device &nbsp;</td>
</tr>
<tr>
<td>&nbsp;&nbsp; 1 &nbsp;</td>
<td>&nbsp;&nbsp; 0 &nbsp;</td>
<td>&nbsp;&nbsp; 0 &nbsp;</td>
<td>&nbsp; &nbsp; &nbsp; 0x54 &nbsp;</td>
<td>&nbsp; Shield #1 (Beaglebone Cape #1)&nbsp;</td>
</tr>
<tr>
<td>&nbsp;&nbsp; 1 &nbsp;</td>
<td>&nbsp;&nbsp; 0 &nbsp;</td>
<td>&nbsp;&nbsp; 1 &nbsp;</td>
<td>&nbsp; &nbsp; &nbsp; 0x55 &nbsp;</td>
<td>&nbsp; Shield #2 (Beaglebone Cape #2)&nbsp;</td>
</tr>
<tr>
<td>&nbsp;&nbsp; 1 &nbsp;</td>
<td>&nbsp;&nbsp; 1 &nbsp;</td>
<td>&nbsp;&nbsp; 0 &nbsp;</td>
<td>&nbsp; &nbsp; &nbsp; 0x56 &nbsp;</td>
<td>&nbsp; Shield #3 (Beaglebone Cape #3)&nbsp;</td>
</tr>
<tr>
<td>&nbsp;&nbsp; 1 &nbsp;</td>
<td>&nbsp;&nbsp; 1 &nbsp;</td>
<td>&nbsp;&nbsp; 1 &nbsp;</td>
<td>&nbsp; &nbsp; &nbsp; 0x57 &nbsp;</td>
<td>&nbsp; Shield #4 (Beaglebone Cape #4)&nbsp;</td>
</tr>
</table>
</p>
<p>
As the microprocesser reads each I2C EEPROM from each expansion board in turn, 
it looks for the "magic number" of "0xd00dfeed (big-endian)" in the first word of each EEPROM. 
If the microprocessor finds the that "magic number", it assumes the EEPROM
contains a Flatten Device Tree data structure, and begins to read it and check it for validity.
Once the microprocessor determines that it contains a valid structure, it begins to install the devices/device drivers.
</p>
<p>
<h2>Device Tree Overlay Pin Multiplexing</h2>
One of the things you might have noticed about the Device Tree Overlay is the specificity of the Pin Multiplexing directives.
Most modern System-on-Chip (SoC) devices have several functions available per pin for application flexibility,
and we need to define what pins are going to be used to connect to the peripherals. 
Unfortunately, the scheme adopted in the Device Tree Overlay is highly specific, 
and tied to the particular processor model used (in this case the AM335X series).
In order to support a wide variety of peripherals attached to a wide variety of 
different processors, it might be better to adopt a more "virtual approach" to I/O pin assignments.
I'll go into this in more detail over the next several articles. 
</p>
<p>
<h2>Summary</h2>
This has been a very brief introduction to the Device Tree Overlay concept,
used for automatically configuring the hardware of embedded computing platforms like the Beaglebone Black,
Xilinx Zynq, and many other System-on-Chip (SOC) devices. 
Support for the Device Tree is still evolving,
and much work remains to be done to foster widespread acceptance on other platforms.
If you are looking for a specific how-to guide for BeagleBone, Raspberry Pi, Xilinx, Altera, etc,
please see the References section at the end of this article for a complete listing. A number of people
in the community have already written some excellent guides and instructions for specific platforms. 
</p>
<p>
In upcoming articles, I'll be making some suggestions for the Device Tree and Device Tree Overlays, 
in order to add features like manufacturing traceability, calibration, virtual I/O, and testing.
</p>
<p>   
<h2>References, Footnotes, and more Device Tree information...</h2>
<ol>
<li><a href="https://events.linuxfoundation.org/sites/events/files/slides/petazzoni-device-tree-dummies.pdf">Device Tree for Dummies - Thomas Petroni</a></li>
<li><a href="https://learn.adafruit.com/introduction-to-the-beaglebone-black-device-tree">BeagleBlack Device Tree Tutorial - Adafruit</a></li>
<li><a href="https://xillybus.com/tutorials/device-tree-zynq-1">Xilinx Device Tree Tutorial - Xillybus</a></li>
<li><a href="https://xillybus.com/tutorials/device-tree-altera-soc-cyclone">Altera Device Tree Tutorial - Xillybus</a></li>
<li><a href="https://blueprints.launchpad.net/ubuntu/+spec/mobile-lucid-arm-device-tree-support">ARM Device Tree Support - Ubuntu</a></li>
<li><a href="https://www.alterawiki.com/wiki/Sopc2dts">Altera Device Tree Support - Altera</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/devicetree/bindings/">Index of Device Tree Bindings - kernal.org</a></li>
<li><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/plain/Documentation/devicetree/bindings/graph.txt">Device Tree Graphing - kernal.org</a></li>
<li><a href="https://packages.debian.org/wheezy/libfdt-dev">libfdt - manipulating FDT Blobs - David Gibson</a></li>
<li><a href="https://www.informit.com/articles/article.aspx?p=1647051&seqNum=5">Linux Bootloaders - informit.com</a></li>
<li><a href="https://haifux.org/lectures/288/haifux-devicetree.pdf">Device Tree PnP - Eli Billauer</a></li>
<li><a href="https://lkml.org/lkml/2013/1/7/366">Device Tree Overlay Manager - Pantelis Antoniou</a></li>
<li><a href="https://lkml.org/lkml/2012/11/5/615">Device Tree Overlay Proposal - Grant Likely</a></li>
<li><a href="https://github.com/cdsteinkuehler/beaglebone-universal-io">BeagleBlack Univeral I/O - cdsteinkuehler</a></li>
<li><a href="https://kilobaser.com/blog/2014-07-28-beaglebone-black-devicetreeoverlay-generator#dtogenerator">BeagleBlack Device Tree Overlay Generator - Kilobaser</a></li>
<li><a href="https://derekmolloy.ie/gpios-on-the-beaglebone-black-using-device-tree-overlays/">GPIOs on the Beaglebone Black using the Device Tree Overlays- derek molloy</a></li>
<li><a href="https://elinux.org/images/f/f2/Supporting_200_Different_Expansionboards_The_Broken_Promise_of_Devicetree.pdf">Supporting 200 Different Expansion Boards -  elinux.org</a></li>
<li><a href="https://events.linuxfoundation.org/sites/events/files/slides/presentation_3.pdf">DT, The Disaster so Far - Mark Rutland</a></li>
<li><a href="https://elinux.org/images/5/5c/ELCE2013_-_DT_War.pdf">Board File to Device Tree Migration - Pantelis Antoniou</a></li>
<li><a href="https://lwn.net/Articles/616859/">Device Tree Overlays - Jonathon Corbet</a></li>
</ol>
</p></div>
      <footer>
        <a rel="full-article" href="/news/2015/01/29/devicetree-overlays.html"></a>
      </footer>
    </article>
  
    
    <article>
      <header>
        <h1 class="entry-title"><a href="/news/2015/01/28/devicetree-overview.html">Device Tree Overview</a></h1>
        
          <p class="meta">
            January 28, 2015
          </p>
        
      </header>
      <div class="entry-content">
      
      
      

<blockquote>
	<p>In nature, nothing is perfect and everything is perfect. Trees can be contorted, bent in weird ways, and they're still beautiful.</p>
	<p>&mdash;Alice Walker</p>
</blockquote>

    <p>Recently, I've been working with the <a href="https://www.devicetree.org/">Device Tree</a> format,
which is becoming widely used for automatically configuring the hardware of embedded computing platforms like the Beaglebone Black,
Xilinx Zynq, Altera Arria, and many other System-on-Chip (SOC) devices. The <a href="https://www.devicetree.org/">Device Tree</a> 
is read during the computing platform boot up sequence, and it describes all the hardware of the embedded computing platform. 
It contains descriptions of all the platform parameters, like how much memory, what kind of interfaces, 
how many peripherals, etc. are expected to be present in that make and model of platform.
In this article, I'll introduce the <a href="https://www.devicetree.org/">Device Tree</a> format, 
and discuss how it is being used on current embedded computing platforms.  
</p>
<!-- more -->
<p>
<h2>What are Device Trees?</h2>
A <a href="https://www.devicetree.org/">Device Tree</a> is a data structure 
for describing the heirarchy of hardware subsystems within a computing platform,  or an add-on peripheral to that platform. 
It can be used to automatically select and configure the device drivers for that computing platform. 
A <a href="https://www.devicetree.org/">Device Tree</a> can be represented in several formats,
such as the human readable "Device Tree Source" format, or the compact, binary, "Flattened Device Tree" format. 
</p>
<p>
<h2>Why Device Tree?</h2>
<img class="illo" src="/news/devicetree/device-tree-nodes.png" alt="Example Device Tree Nodes" title="Example Device Tree Nodes"/>
As many new and different System-on-Chip (SOC) based embedded computing platforms started appearing a few years ago, 
it became increasingly difficult to support all the various operating system configurations required
for Linux, IOS, Windows, and others.
</p>
<p>
Prior to the adoption of the <a href="https://www.devicetree.org/">Device Tree</a> format,
this platform information was contained in what is known as the 
<a href="https://en.wikipedia.org/wiki/Board_support_package">Board Support Package (BSP)</a>,
a group of files provided by the manufacturer of that particular board.
Each new operating system version would need to include the hardware configuration information
from the <a href="https://en.wikipedia.org/wiki/Board_support_package">Board Support Package (BSP)</a>
in order to be able to run on that particular board. This quickly became a bottleneck in the process
of supporting new computing platforms that had only minor variations, so Linus Torvalds and others needed to 
<a href="https://article.gmane.org/gmane.linux.ports.arm.omap/55060">push back</a>, 
and come up with a more dynamic method of describing the hardware of the computing platform. 
</p>
<p>
The <a href="https://www.devicetree.org/">Device Tree</a> format was adopted to serve as the container format
for hardware configuration information required during the boot process, however a way was still needed to
modify the system after the boot up process, and to support expansion boards and subsystems.
Pantelis Antoniu, Grant Likely, and others have outlined a solution that
allows for <a href="https://lkml.org/lkml/2013/1/7/366">Device Tree Overlays</a>, and an 
<a href="https://lkml.org/lkml/2013/1/7/366">expansion board (Cape) manager</a>
to modify the <a href="https://www.devicetree.org/">Device Tree</a> from user-space, during run-time.
This allows users to load and unload hardware peripherals and drivers as needed.
The transition away from solely using <a href="https://en.wikipedia.org/wiki/Board_support_package">Board Support Package (BSP)</a> 
files to the <a href="https://www.devicetree.org/">Device Tree</a> format is ongoing,
and <a href="https://elinux.org/images/5/5c/ELCE2013_-_DT_War.pdf">not without it's share of problems</a>.
</p>
<p>
<h2>Embedded Device Trees</h2>
So, what is an embedded device tree, and how do we describe it?
Let's look at a common example, say the  <a href="https://beagleboard.org/BLACK">BeagleBone Black</a>, which uses an OMAP3 System-on-Chip from Texas Instruments.
A very (very) simplified example, including just the CPU and it's main memory, would look something like this :
</p>
<p>
<table>
<tr>
<td>&nbsp;</td>
<td>
<img src="/news/sff/beagleboneblack.png" alt="BeagleBone Black" title="BeagleBone Black"/>
</td>
<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>
<img src="/news/devicetree/device-tree-bbb.png" alt="BeagleBone Black Device Tree" title="BeagleBone Black Device Tree"/>
</td>
<td>&nbsp;</td>
</tr>
</table>
</p>
<p>
The corresponding <a href="https://www.devicetree.org/">Device Tree Source (.dts)</a> file for the above would look something like :
<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="p">{</span>
        <span class="n">model</span>      <span class="o">=</span> <span class="s">"TI AM335x BeagleBone Black"</span><span class="p">;</span>
        <span class="n">compatible</span> <span class="o">=</span> <span class="s">"ti,beaglebone-black"</span><span class="p">,</span>
                     <span class="s">"ti,am335x-boneblack"</span><span class="p">,</span>
                     <span class="s">"ti,am335x-bone"</span><span class="p">,</span>
                     <span class="s">"ti,am33xx"</span><span class="p">;</span>
        <span class="n">cpus</span> <span class="p">{</span>
                <span class="n">cpu</span><span class="err">@</span><span class="mi">0</span> <span class="p">{</span>
                       <span class="n">cpu0</span><span class="o">-</span><span class="n">supply</span> <span class="o">=</span> <span class="o">&lt;&amp;</span><span class="n">dcdc2_reg</span><span class="o">&gt;</span><span class="p">;</span>	
                <span class="p">};</span>	
        <span class="p">};</span>	
        <span class="n">memory</span> <span class="p">{</span>	
                <span class="n">device_type</span> <span class="o">=</span> <span class="s">"memory"</span><span class="p">;</span>
                <span class="n">reg</span> <span class="o">=</span> <span class="o">&lt;</span><span class="mh">0x80000000</span> <span class="mh">0x10000000</span><span class="o">&gt;</span><span class="p">;</span> <span class="cm">/* 256 MB */</span>	
        <span class="p">};</span>
<span class="p">};</span></pre></td></tr></tbody></table></code></pre></figure>
</p>
<p>
As we can see from the above <a href="https://www.devicetree.org/">Device Tree Source (.dts)</a> example, we have defined the following :
<ul>
<li>model &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : defines the model name of this board</li>
<li>compatible : defines the manufacturer & model compatibility list</li>
<li>cpus &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;: defines a single cpu with a node name of "cpu", and what power supply it uses</li>
<li>memory &nbsp; &nbsp; &nbsp; : defines 256 MegaBytes of main memory on this model, and it's address range</li>
</ul>
Of course, the actual Device Tree Source (.dts) file, in this case, the 
<a href="https://git.ti.com/wilink8-wlan/wilink8-wlan-ti-linux-kernel/blobs/9bf81aa9157a358fa53ab015e01c08bc68788709/arch/arm/boot/dts/am335x-bone-common.dtsi">am335x-bone-common.dtsi</a> include file has much more detail, but I'll build up the concepts gradually using simplified snippets.
</p>
<p>
Next we'll add some input/output to the Device Tree Source (.dts) file, and we'll start with a simple I2C controller
in order to create a tiny, but useful little computing platform description : 
<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre><span class="p">{</span>
        <span class="n">model</span>      <span class="o">=</span> <span class="s">"TI AM335x BeagleBone Black"</span><span class="p">;</span>
        <span class="n">compatible</span> <span class="o">=</span> <span class="s">"ti,beaglebone-black"</span><span class="p">,</span>
                     <span class="s">"ti,am335x-boneblack"</span><span class="p">,</span>
                     <span class="s">"ti,am335x-bone"</span><span class="p">,</span>
                     <span class="s">"ti,am33xx"</span><span class="p">;</span>
        <span class="n">cpus</span> <span class="p">{</span>
                <span class="n">cpu</span><span class="err">@</span><span class="mi">0</span> <span class="p">{</span>
                       <span class="n">cpu0</span><span class="o">-</span><span class="n">supply</span> <span class="o">=</span> <span class="o">&lt;&amp;</span><span class="n">dcdc2_reg</span><span class="o">&gt;</span><span class="p">;</span>	
                <span class="p">};</span>	
        <span class="p">};</span>	
        <span class="n">memory</span> <span class="p">{</span>	
                <span class="n">device_type</span> <span class="o">=</span> <span class="s">"memory"</span><span class="p">;</span>
                <span class="n">reg</span> <span class="o">=</span> <span class="o">&lt;</span><span class="mh">0x80000000</span> <span class="mh">0x10000000</span><span class="o">&gt;</span><span class="p">;</span> <span class="cm">/* 256 MB */</span>	
        <span class="p">};</span>
        <span class="n">am33xx_pinmux</span><span class="o">:</span> <span class="n">pinmux</span><span class="err">@</span><span class="mf">44e10800</span> <span class="p">{</span>
		<span class="n">pinctrl</span><span class="o">-</span><span class="n">names</span> <span class="o">=</span> <span class="s">"default"</span><span class="p">;</span>
		<span class="n">pinctrl</span><span class="o">-</span><span class="mi">0</span> <span class="o">=</span> <span class="o">&lt;&amp;</span><span class="n">clkout2_pin</span><span class="o">&gt;</span><span class="p">;</span>
		<span class="n">i2c0_pins</span><span class="o">:</span> <span class="n">pinmux_i2c0_pins</span> <span class="p">{</span>
			<span class="n">pinctrl</span><span class="o">-</span><span class="n">single</span><span class="p">,</span><span class="n">pins</span> <span class="o">=</span> <span class="o">&lt;</span>
                                <span class="cm">/* i2c0_sda.i2c0_sda pin */</span>
				<span class="mh">0x188</span> <span class="p">(</span><span class="n">PIN_INPUT_PULLUP</span> <span class="o">|</span> <span class="n">MUX_MODE0</span><span class="p">)</span>
				<span class="cm">/* i2c0_scl.i2c0_scl */</span>
				<span class="mh">0x18c</span> <span class="p">(</span><span class="n">PIN_INPUT_PULLUP</span> <span class="o">|</span> <span class="n">MUX_MODE0</span><span class="p">)</span>
			<span class="o">&gt;</span><span class="p">;</span>
		<span class="p">};</span>
        <span class="p">};</span>
        <span class="n">ocp</span> <span class="p">{</span>
		<span class="n">i2c0</span><span class="o">:</span> <span class="n">i2c</span><span class="err">@</span><span class="mf">44e0</span><span class="n">b000</span> <span class="p">{</span>
			<span class="n">pinctrl</span><span class="o">-</span><span class="n">names</span> <span class="o">=</span> <span class="s">"default"</span><span class="p">;</span>
			<span class="n">pinctrl</span><span class="o">-</span><span class="mi">0</span> <span class="o">=</span> <span class="o">&lt;&amp;</span><span class="n">i2c0_pins</span><span class="o">&gt;</span><span class="p">;</span>
			<span class="n">status</span> <span class="o">=</span> <span class="s">"okay"</span><span class="p">;</span>
			<span class="n">clock</span><span class="o">-</span><span class="n">frequency</span> <span class="o">=</span> <span class="o">&lt;</span><span class="mi">400000</span><span class="o">&gt;</span><span class="p">;</span>
			<span class="n">tps</span><span class="o">:</span> <span class="n">tps</span><span class="err">@</span><span class="mi">24</span> <span class="p">{</span>
				<span class="n">reg</span> <span class="o">=</span> <span class="o">&lt;</span><span class="mh">0x24</span><span class="o">&gt;</span><span class="p">;</span>
			<span class="p">};</span>
        <span class="p">};</span>
<span class="p">};</span></pre></td></tr></tbody></table></code></pre></figure>
</p>
<p>
The first thing we added above is the I/O Pin Multiplexing defintions, as most modern System-on-Chip (SoC) devices have several
functions available per pin for application flexibility. We need to define what pins are going to be used to connect the 
<a href="https://en.wikipedia.org/wiki/I%C2%B2C">I2C</a> controller to the outside world.
<ul>
<li>am33xx_pinmux: the label for the pin multiplexing control registers (pinmux) at address 0x44e10800 </li>
<li>i2c0_pins : the label for the pins assigned to the <a href="https://en.wikipedia.org/wiki/I%C2%B2C">I2C</a> Controller at offsets 0x188 and 0x18C</li>
</ul>
</p>
<p>
The next section defines the <a href="https://en.wikipedia.org/wiki/I%C2%B2C">I2C</a> controller itself, which is located on the 
<a href="https://en.wikipedia.org/wiki/Open_Core_Protocol">OCP bus (Open Core Protocol)</a>
which is the name for one of internal bus connections in the System-on-Chip (SoC):
<ul>
<li>i2c0: the label for the first I2C controller block at address 0x44e0b000 </li>
<li>status: we expect the I2C controller block status to be operational</li>
<li>clock-frequency: the I2C bus is running at 400Khz</li>
</ul>
<p>
And finally, we describe a sub-node of the <a href="https://en.wikipedia.org/wiki/I%C2%B2C">I2C</a> 
controller (i.e. an attached I2C device), called "tps":
<li>tps: the label for the power supply controller chip</li>
<li>reg: the I2C bus address for the "tps" device is 0x24 
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (this is a "subnode" or indirect address)</li>
</ul>
</p>
<p>
Alright, now we need to define the "tps" node to make this a more complete <a href="https://www.devicetree.org/">Device Tree Source (.dts)</a> file,
which allows me to introduce the concept of power supply descriptions. It is really useful to know how much power that the power supplies on
a board are capable of providing, and what additional power that expansion devices or add-on boards will require. 
That will allow us to indicate an error if an expansion device requires more power than we are capable of providing.

</div>
      <footer>
        <a rel="full-article" href="/news/2015/01/28/devicetree-overview.html"></a>
      </footer>
    </article>
  
    
    <article>
      <header>
        <h1 class="entry-title"><a href="/news/2015/01/27/sensor-abilities.html">Sense and Sensor Abilities</a></h1>
        
          <p class="meta">
            January 27, 2015
          </p>
        
      </header>
      <div class="entry-content">
      
      
      

<blockquote>
	<p>It isn't what we say or think that defines us, but what we do.</p>
	<p>&mdash;Jane Austen</p>
</blockquote>

    <p>There are several efforts underway to define and unify sensor abilities and parameters,
both for normal (user) applications as well as for standardized (manufacturer) testing. 
Today it can be quite difficult to change sensor elements 
(either because newer, better sensor products become available, 
or because of the obsolescence of older, existing models)
due to the amount of software changes involved.
In this article, I'll discuss some of the evolving standards efforts underway, 
and what that means for those of us trying to keep up with the latest sensor technologies,
and those of us trying to determine whether or not a particular sensor meets our requirements.
</p>
<!-- more -->
<p>
There has been a lot of activity around Micro-Electro-Mechanical Systems(MEMS) sensors in the last
few years, enabling everything from self-leveling drone 'copters to exercise wristbands.
While that is great news for product designers and consumers, one of the areas that has not
kept pace with this explosion of new products and capabilites, has been a standardized method 
for comparing and contrasting the specifications of these new devices.  
The <a href="https://www.ieee.org/index.html">IEEE</a>, in conjunction with the 
<a href="https://www.memsindustrygroup.org/">MEMS Industry Group (MIG)</a> 
have been working on a specification to define Sensor Parameters in a more consistant
and formal way, known as <a href="https://standards.ieee.org/findstds/standard/2700-2014.html">IEEE 2700-2014</a>,
the IEEE Standard for Sensor Performance Parameters. 
</p>
<p>
<img class="illo" src="/news/sensor-abilities/nist-std-weights.png" width="395" height="362" alt="NIST Standard Weights" title="NIST Standard Weights"/>
<a href="https://standards.ieee.org/findstds/standard/2700-2014.html">IEEE 2700-2014</a> describes a set of definitions
for the parameters of different sensor types, as well as terms, acronyms, symbols, measurement conventions and conversions.
The recently ratified standard includes all the usual suspects, such as :
<ul>
<li>Accelerometers</li>
<li>Gyroscopes</li>
<li>Magnetometers (i.e. MEMS Compass)</li>
<li>Temperature</li>
<li>Pressure</li>
<li>Humidity</li>
<li>Proximity</li>
<li>Light</li>
</ul>
</p>
<p>
This is good news for developers, as standard "terms", like parameter names, units, and measurement techniques
are very important for comparing "apples to apples" where sensor performance is concerned. So, what kind of parameters
are defined in <a href="https://standards.ieee.org/findstds/standard/2700-2014.html">IEEE 2700-2014</a>?
The parameters can vary for each type of sensor element; a Magnetometer (i.e. MEMS Compass) for example can
have parameters such as : 
<ul>
<li>Full Scale Range</li>
<li>Offset at Zero Magnetic Field</li>
<li>Offset Temperature Coefficient</li>
<li>Sensitivity</li>
<li>Sensitivity Temperature Coefficient</li>
<li>Noise</li>
<li>Current Consumption</li>
<li>Filter-3DB Cutoff</li>
<li>Cross-Axis Sensitivity</li>
<li>Integral Non-Linearity</li>
<li>Acquisition Time</li>
</ul>
</p>
<p>
This is a good first effort at defining all the important parameters, their units of measurement,
and the conditions under which those parameters are specified. As more manufacturers adopt the
<a href="https://standards.ieee.org/findstds/standard/2700-2014.html">IEEE 2700-2014</a> standard,
it will make things much easier for designers and programmers to understand their data sheets
and specifications. 
</p>
<p>
In terms of software developments, there are a number of 
<a href="https://en.wikipedia.org/wiki/Sensor_fusion">Sensor Fusion</a> initiatives underway, including offerings from
<a href="https://www.st.com/web/catalog/sense_power/FM89/SC1950">ST Microelectronics</a>, Freescale, and many others.
Most of these vendors refer to the collection of sensor hardware necessary to integrate all the disparate sensors as a 
<a href="https://en.wikipedia.org/wiki/Sensor_hub">Sensor Hub</a>. Companies like Microsoft consider these efforts to be so critical
that they have made it mandatory for Windows 8 and Windows 10 to support sensors in the Human Interface Device (HID) specification.
And the <a href="https://www.memsindustrygroup.org/">MEMS Industry Group (MIG)</a> is working on an 
<a href="https://github.com/memsindustrygroup/Open-Source-Sensor-Fusion">Open Source Sensor Fusion</a> initiative for
<a href="https://en.wikipedia.org/wiki/Sensor_fusion">Sensor Fusion</a>, including a body of work donated by by Freescale.
</p>
<p>
For smaller, embedded systems, 
<img class="illo" src="https://learn.adafruit.com/system/assets/assets/000/004/549/medium800/microcontrollers_sensorapi.jpg?1396814289" alt="Adafruit Unified Sensor Driver" title="Adafruit Unified Sensor Driver"/>
Kevin Townsend at <a href="https://www.adafruit.com">Adafruit</a> has developed a
<a href="https://learn.adafruit.com/using-the-adafruit-unified-sensor-driver/introduction">Unified Sensor Driver</a>
that is similar to how the  
<a href="https://github.com/android/platform_hardware_libhardware/blob/master/include/hardware/sensors.h">Android Operating System</a>
abstracts all sensor parameters into a single unified type with standard, pre-defined SI units of measure. This is a very nice way to go,
as users are now free to select any sensor model of a particular type, and their higher level software doesn't need to be rewritten
when their hardware changes. And once <a href="https://standards.ieee.org/findstds/standard/2700-2014.html">IEEE 2700-2014</a> becomes
more prevalent, it will become even easier to implement the underlying 
<a href="https://learn.adafruit.com/using-the-adafruit-unified-sensor-driver/introduction">Unified Sensor Drivers</a>.
</p>
<p>
In coming articles, I'll discuss using the <a href="https://www.devicetree.org/">DeviceTree</a> to automatically
discover and configure attached sensors, and to define their parameters in a method that is compatible with 
<a href="https://standards.ieee.org/findstds/standard/2700-2014.html">IEEE 2700-2014</a>.
</p>
</div>
      <footer>
        <a rel="full-article" href="/news/2015/01/27/sensor-abilities.html"></a>
      </footer>
    </article>
  
    
    <article>
      <header>
        <h1 class="entry-title"><a href="/news/2015/01/25/the-blob.html">The BLOB - Binary Level OBjects</a></h1>
        
          <p class="meta">
            January 25, 2015
          </p>
        
      </header>
      <div class="entry-content">
      
      
      

<blockquote>
	<p>Obstacles are those frightful things you see when you take your eyes off your goal.</p>
	<p>&mdash;Henry Ford</p>
</blockquote>

    <p>There are a number of different metadata formats for containing low-level configuration information,
some of them are in plain ASCII text, and others are in various encoded binary formats. The encoded binary formats, or 
Binary Level OBjects, are commonly referred to as 
<a href="#BLOB">"BLOBs"</a>. 
In this article, I will discuss how some of those formats are being used in existing products.
</p>
<!-- more -->
<p>
<img class="illo" src="/news/theblob/Blob-Town.png" width="320" height="300" alt="Blob Town" title="Blob Town"/>
Let's start with the <a href="https://www.devicetree.org/Device_Tree_Usage">DeviceTree</a> format, 
which is often utilized in describing the hardware of higher end platforms to the Linux Kernal. 
The <a href="https://www.devicetree.org/Device_Tree_Usage">DeviceTree</a> definition starts with a
<a href="https://lxr.free-electrons.com/source/arch/arm/boot/dts/imx28-evk.dts">DeviceTree Specification File</a>
also known as a .dts file. The <a href="https://lxr.free-electrons.com/source/arch/arm/boot/dts/imx28-evk.dts">DeviceTree Specification File</a>
is a human readable definiton of everything about the embedded platform, including CPU type, amount of memory, internal buses (AHB/APB/etc.),
and all the relevent interfaces, like USB, UART, PCI, SPI/MMC, Ethernet MAC, GPIO pins, Pin Multiplexing, and more. 
It is a very complete specification of the underlying hardware platform. 
The <a href="https://lxr.free-electrons.com/source/arch/arm/boot/dts/imx28-evk.dts">DeviceTree Specification File</a>
is then run through the <a href="https://www.devicetree.org/Device_Tree_Compiler">DeviceTree Compiler</a> which produces the 
<a href="https://www.devicetree.org/Device_Tree_Compiler">DeviceTree Binary Object</a> (i.e. The Blob) which is also known as the ".dtb" file.
The <a href="https://www.devicetree.org/Device_Tree_Compiler">DeviceTree Binary Object</a> (i.e. The Blob of the "Flattened Device Tree") is
typically read in as part of the operating system booting procedure, and used to determine what device drivers are loaded into the operating system.
I'll go into how this process works in much more detail in a later article, but that's the basic idea of a compiled Device Tree.   
</p>
<p>
So how does this process relate to the <a href="https://www.intel.com/content/www/us/en/servers/ipmi/information-storage-definition-rev-1-2.html">IPMI FRU</a> : (Intelligent Peripheral Management Interface - Field Replaceable Unit) data structure definition for add-on boards,
and the <a href="https://standards.ieee.org/findstds/standard/1451.4-2004.html">TEDS</a> (Transducer Electronic Data Sheet)
data structure definition for attached Sensor devices? The following diagram depicts their relationship :
</p>
<p>
<img src="/news/theblob/blobs-diagram.png" alt="Embedded Blobs" title="Embedded Blobs"/>
</p>
<p>
So, to put this all together in a more simple explaination :
<ul>
<li>During the Main Board boot-up sequence, the <a href="https://www.devicetree.org/Device_Tree_Usage">Device Tree</a> BLOB is
    parsed to determine all of the hardware interfaces contained on the Main Board.</li>
<li>After the initial Main Board boot-up sequence, the 
    <a href="https://www.intel.com/content/www/us/en/servers/ipmi/information-storage-definition-rev-1-2.html">IPMI FRU</a> is
    parsed to determine the make and model of the attached Expansion Board, which identifies the attached Sensors.
</li>
<li>Then the <a href="https://standards.ieee.org/findstds/standard/1451.4-2004.html">TEDS</a> BLOBs are each  
    parsed to determine the parameters of the attached Sensors.
</li>
<li>Finally, the Operating System (Linux/Android) has all the information necessary to read and interpret the attached Sensors.</li>
</ul>
</p>
<p>
That is a very quick overview of what is a highly complex process for automatic discovery and configuration, 
based on currently used standards. The upshot of all of this is that at least three (3) separate and
distinct parsers (namely DeviceTree, IPMI FRU, and TEDS, respectively) are required to put all of this together. 
For an embedded Linux system, such as a Xilinx Zynq based system, or an ARM A8/A9 class system, 
we are talking about a fairly large amount of code to implement each of the different parsers 
required to extract the necessary information. Do we really need three (3) or different ways (or more...)
to encode similar data like this? Isn't there a more uniform way to accomplish this? 
</p>
<p>
As one of my engineering buddies used to say, 
<i>"Standards are great, and there are so many incompatible ones to choose from!"</i>
Clearly this kind of approach is going to be more difficult on resource constrained small systems,
such as the Arduino, rfDuino, and TI LaunchPad. So, what can we do to improve the current state of the art here?
</p>
<p>
In our next segment, we'll discuss several of the evolving standards for Sensor Parameters
that are being used in Sensor Hub and Sensor Fusion implementations, and what that means
for developing an all encompassing method of automatic discovery and configuration
on small form factor embedded platforms.
</p>
<p>
<table border="0">
<tr>
<td>
And finally, for your viewing pleasure, the original trailer for the 1958 feature "The Blob",
starring a very young Steve McQueen. I still remember the first time I saw this movie, in
a Drive-In Theater with my parents and family, in a
<a href="https://www.youtube.com/watch?v=eOm5P1AkUi4">Studebaker Wagonaire</a>.
</td>
<td>
  <div class="container.four-three">
	  <iframe width="427" height="255" src="//www.youtube.com/embed/TdUsyXQ8Wrs?HD=1;rel=0;showinfo=0;controls=0" frameborder="0" allowfullscreen></iframe>
  </div>
</td>
</tr>
</table>
</p>
<p>
&nbsp;
</p>
<p>
<a name="#BLOB"></a>
<a href="https://en.wikipedia.org/wiki/Binary_large_object">Wikipedia</a> attributes the programming reference of "BLOBs"as a
<a href="https://en.wikipedia.org/wiki/Backronym"><i>backronym</i></a> to Terry McKiever, a marketing person for Apollo;
who felt that it needed to be an acronym and invented the "Basic Large Object", which became widely used as "Binary Large Object".
Since what I'm trying to implement are very small objects, I prefer the acronym, "Binary Level OBject".
</p>
<p>
</p>

</div>
      <footer>
        <a rel="full-article" href="/news/2015/01/25/the-blob.html"></a>
      </footer>
    </article>
  
    
    <article>
      <header>
        <h1 class="entry-title"><a href="/news/2015/01/23/the-great-chain.html">Automatic Configuration Chains</a></h1>
        
          <p class="meta">
            January 23, 2015
          </p>
        
      </header>
      <div class="entry-content">
      
      
      

<blockquote>
	<p>There are more things in heaven and earth, Horatio, than are dreamt of in your philosophy.</p>
	<p>&mdash;Shakespeare - "Hamlet"</p>
</blockquote>

    <p>In order to design an automatic discovery and configuration mechanism for popular 
small form factors like Arduino, rfDuino, LaunchPad, and others,
we first need to decide on simple connection chain that can connect all the 
subsystems, one which is already included in each of these form factors.
We need to be able to describe the heirarchy of devices, and the connections between them, 
in order to understand the topology of our embedded system.
</p>
<!-- more -->
<p>
The problem reminds me somewhat of that faced by the early philosophers in trying to understand
their place in the hierarchy of the universe. Aristotle's 
<a href="https://en.wikipedia.org/wiki/History_of_Animals">History of Animals</a> 
classified organisms in relation to a linear "ladder of life", or <i>Scala Naturae</i>,
which allowed for an ordering of beings, from dirt at the bottom, to God at the very top,   <a href="http://opensoundcontrol.org"><img class="illo" src="/news/osc/osc-flowers.png" alt="Summer of OSC"/></a>
with all creatures occupying rungs of the ascending ladder between.
The <a href="https://faculty.up.edu/asarnow/greatchainofbeing.htm">Great Chain of Being</a>
connected all things, as all things were linked together to form the universe in one solid, unbroken chain.
By the time of the Renaissance, the concept of <a href="https://faculty.up.edu/asarnow/greatchainofbeing.htm">Great Chain of Being</a> 
had become pervasive, used to justify the feudal system and the divine right of kings. 
Later still, this would influence poets such as Robert Blake to compose lines like, "As above, so below".
</p>
<p>
We also need to define a chain of physical entities, and the links that make up their interconnections.   <a href="http://opensoundcontrol.org"><img class="illo" src="/news/osc/osc-flowers.png" alt="Summer of OSC"/></a>
In reality, we will need to define several, as some may be connected only by wireless linkages,
but for this introduction, we will discuss only the physically connected entities, such as an Ardunio Shield,
rfDuino, Launchpad, and the like.
</p>
<p>
The simplest and most ubiquitous interface found on all of these platforms is 
<a href="https://en.wikipedia.org/wiki/I%C2%B2C">I2C</a>, or the Inter-Integrated Circuit bus.
Also known as the "Two-Wire Bus" or TWB, <a href="https://en.wikipedia.org/wiki/I%C2%B2C">I2C</a>
is found on almost every embedded platform, and can be easily implemented with software 
<a href="https://en.wikipedia.org/wiki/Bit_banging">bit banging</a> on general purpose I/O pins (GPIO),
if a hardware interface block is not readily available. In addition, the 
<a href="https://www.mipi.org/">MIPI Alliance</a> is in the final stages of the ratification process for the new
<a href="https://mipi.org/specifications/i3c%E2%84%A0-sensor-specification">SenseWire/I3C Sensor Interface Specification</a>;
I3C defines a much higher performance interface, capable of supporting many more high speed sensors than
the original <a href="https://en.wikipedia.org/wiki/I%C2%B2C">I2C</a> bus specification.
</p>
<p>
<a href="https://en.wikipedia.org/wiki/I%C2%B2C">I2C</a> is a good choice for this purpose,
as it is both commonly available, and also supports the very low cost 
<a href="https://playground.arduino.cc/Code/I2CEEPROM">I2C EEPROMs</a> that we will
need for our configuration storage. An example implementation of this automatic configuration scheme
would resemble the diagram below : 
</p>
<p>
<img src="/news/osc/i2c_mmi.png" alt="I2C Configuration Chain" title="I2C Configuration Chain"/>
</p>
<p>
Typical <a href="https://playground.arduino.cc/Code/I2CEEPROM">I2C EEPROMs</a> employ a three(3) bit hardware
selection mechanism, allowing up to eight(8) devices to share the same <a href="https://en.wikipedia.org/wiki/I%C2%B2C">I2C</a> bus.
In communicating with the <a href="https://playground.arduino.cc/Code/I2CEEPROM">I2C EEPROMs</a>, the first byte sent
is the control word, which serves to select which one of the eight(8) devices will respond to the read/write operation
on the shared <a href="https://en.wikipedia.org/wiki/I%C2%B2C">I2C</a> bus. 
</p>
<p>
<img src="/news/great_chain/i2c_register.png" alt="I2C Register" title="I2C Register"/>
</p>
<p>
Using this addressing scheme, we can support up to eight(8) levels of devices in our stack, which should be
adequate for most purposes. The standard addressing for each level is shown in the table below :
<br>
<table border="2" spacing="2">
<tr>
<td>&nbsp; A2 &nbsp;</td>
<td>&nbsp; A1 &nbsp;</td>
<td>&nbsp; A0 &nbsp;</td>
<td>&nbsp; I2C Address &nbsp;</td>
<td>&nbsp; Device &nbsp;</td>
</tr>
<tr>
<td>&nbsp;&nbsp; 0 &nbsp;</td>
<td>&nbsp;&nbsp; 0 &nbsp;</td>
<td>&nbsp;&nbsp; 0 &nbsp;</td>
<td>&nbsp; &nbsp; &nbsp; 0x50 &nbsp;</td>
<td>&nbsp; Chassis (Power Supply) &nbsp;</td>
</tr>
<tr>
<td>&nbsp;&nbsp; 0 &nbsp;</td>
<td>&nbsp;&nbsp; 0 &nbsp;</td>
<td>&nbsp;&nbsp; 1 &nbsp;</td>
<td>&nbsp; &nbsp; &nbsp; 0x51 &nbsp;</td>
<td>&nbsp; Boot Processor #0 (Arduino, BeagleBone) &nbsp;</td>
</tr>
<tr>
<td>&nbsp;&nbsp; 0 &nbsp;</td>
<td>&nbsp;&nbsp; 1 &nbsp;</td>
<td>&nbsp;&nbsp; 0 &nbsp;</td>
<td>&nbsp; &nbsp; &nbsp; 0x52 &nbsp;</td>
<td>&nbsp; CoProcessor #1 (Logger)&nbsp;</td>
</tr>
<tr>
<td>&nbsp;&nbsp; 0 &nbsp;</td>
<td>&nbsp;&nbsp; 1 &nbsp;</td>
<td>&nbsp;&nbsp; 1 &nbsp;</td>
<td>&nbsp; &nbsp; &nbsp; 0x53 &nbsp;</td>
<td>&nbsp; CoProcessor #2 (Logic Analyzer)&nbsp;</td>
</tr>
<tr>
<td>&nbsp;&nbsp; 1 &nbsp;</td>
<td>&nbsp;&nbsp; 0 &nbsp;</td>
<td>&nbsp;&nbsp; 0 &nbsp;</td>
<td>&nbsp; &nbsp; &nbsp; 0x54 &nbsp;</td>
<td>&nbsp; Shield #1 (Beaglebone Cape #1)&nbsp;</td>
</tr>
<tr>
<td>&nbsp;&nbsp; 1 &nbsp;</td>
<td>&nbsp;&nbsp; 0 &nbsp;</td>
<td>&nbsp;&nbsp; 1 &nbsp;</td>
<td>&nbsp; &nbsp; &nbsp; 0x55 &nbsp;</td>
<td>&nbsp; Shield #2 (Beaglebone Cape #2)&nbsp;</td>
</tr>
<tr>
<td>&nbsp;&nbsp; 1 &nbsp;</td>
<td>&nbsp;&nbsp; 1 &nbsp;</td>
<td>&nbsp;&nbsp; 0 &nbsp;</td>
<td>&nbsp; &nbsp; &nbsp; 0x56 &nbsp;</td>
<td>&nbsp; Shield #3 (Beaglebone Cape #3)&nbsp;</td>
</tr>
<tr>
<td>&nbsp;&nbsp; 1 &nbsp;</td>
<td>&nbsp;&nbsp; 1 &nbsp;</td>
<td>&nbsp;&nbsp; 1 &nbsp;</td>
<td>&nbsp; &nbsp; &nbsp; 0x57 &nbsp;</td>
<td>&nbsp; Shield #4 (Beaglebone Cape #4)&nbsp;</td>
</tr>
</table>
</p>
<p>
You'll notice that the Arduino (or Launchpad, etc.) is not at the 
very bottom of the stack, as there may be a chassis or other lower level that
the stack is mounted within, in order to provide battery or solar power to the system.
We may need to be able to interogate that level to inquire how much power is available,
or inquire about other parameters. In later articles, I'll outline some other uses
for the lowest level, such as instrumentation, testing, and monitoring of the system.
</p>
<p>
So, what about more than eight(8) levels you might be asking? What then?
Well, the <a href="https://en.wikipedia.org/wiki/I%C2%B2C">I2C</a> bus has
some physical loading limitations, that have to do with the larger bus capacitances
that result when you extend the bus too far, or add too many loads(devices). 
In practice, there may need to be 
<a href="https://en.wikipedia.org/wiki/I%C2%B2C">I2C</a> bus buffers, repeaters,
hubs, or multiplexors employed to keep each segment of the 
<a href="https://en.wikipedia.org/wiki/I%C2%B2C">I2C</a> bus within specified loading limits.
However, the addressing scheme above would apply to each separate segment of a larger
system, although you may need to address a multiplexor or hub first to select a
particular segment to read or write.
</p>
<p>
You might also notice that the Beaglebone "Capes" (the name for their expansion boards)
are limited to four(4) "Capes", this is a specific limitation of the Beaglebone.
</p>
<p>
We now have a basic outline for a hardware design pattern for automatic discovery
and automatic configuration using simple I2C interfaced EEPROM memory chips.
The next step is to define the data structure within each of the 
<a href="https://playground.arduino.cc/Code/I2CEEPROM">I2C EEPROMs</a> shown,
and how that data structure defines the components and topology of the overall system.
The next article will cover currently available data structures like the Device Tree
and IPMI formats. 
</p></div>
      <footer>
        <a rel="full-article" href="/news/2015/01/23/the-great-chain.html"></a>
      </footer>
    </article>
  
    
    <article>
      <header>
        <h1 class="entry-title"><a href="/news/2015/01/22/SFF-SelfConfig.html">Small Form Factor Auto-Configuration</a></h1>
        
          <p class="meta">
            January 22, 2015
          </p>
        
      </header>
      <div class="entry-content">
      
      
      

<blockquote>
	<p>Do the difficult things while they are easy and do the great things while they are small. A journey of a thousand miles must begin with a single step.</p>
	<p>&mdash;Lao Tzu</p>
</blockquote>

    <p>I spoke at the 
<a href="https://www.meetup.com/Thing-Tuesday-The-Portland-Internet-of-Things-Meetup/">Portland thingTuesday</a>
meeting this week about some of the limitations of currently popular small form factors like 
Arduino, rfDuino, TI LaunchPad, and others. 
My personal opinion is that one of the biggest limitations of these small form factors 
is the lack of an automatic configuration standard. 
</p>
<!-- more -->
<p>
In other words, when you plug a shield into an Arduino Leonardo for example, 
the Arduino has no idea of what shield is present, or how to talk to it.
I contrast this with something like PCI, or USB, where a device descriptor table
can be interrogated to determine things like the manufacturer and product names.
In my talk, I asserted that this was one of the reasons that made USB and PCI/PCI-E
so successful; this ability is one of the things that makes them easy to use. 
</p>
<p>
So I started looking around at some of the existing standards out there in order
to see if there wasn't already something available that could be used for this purpose.
Some of the descriptor formats that I looked at were :
<ul>
 <li><a href="https://www.usb.org/">USB</a> : Universal Serial Bus</li>
 <li><a href="https://www.pcisig.com/specifications">PCI</a> : Peripheral Component Interconnect</li>
 <li><a href="https://standards.ieee.org/findstds/standard/1451.4-2004.html">TEDS</a> : Transducer Electronic Data Sheet</li>
 <li><a href="https://www.intel.com/content/www/us/en/servers/ipmi/information-storage-definition-rev-1-2.html">IPMI FRU</a> : Intelligent Peripheral Management Interface - Field Replaceable Unit</li>
 <li><a href="https://www.devicetree.org/">Device Tree</a> : Linux Device Tree Hardware Description</li>
</ul>
USB, PCI, and TEDS are all controlled by various associations, 
which cost money to join and to obtain a Vendor/Manufacturer ID number.
Additionally, those ID pools are quite small (64K for USB, 16K for TEDS),
which limits the number of folks who can "join their club",
and also mandates a look-up of an assigned number (i.e. VID) to a 
human readable name. 
</p>
<p>
<a href="https://www.intel.com/content/www/us/en/servers/ipmi/ipmi-specifications.html">IPMI</a> 
on the other hand, a standard developed by Intel, HP, NEC, and Dell
has been widely adopted by computer server manufacturers, and utilizes
plain text fields to store design metadata like Manufacturer Name, 
Serial Number, Asset Tag, UUID, MAC ID, and more. The FMC (FPGA Module Carrier)
standard from <a href="https://www.vita.com/specifications">VITA</a>
adds additional fields to describe power supply requirements.
I also liked the idea of just being able to put something like "Joe's Garage"
as a Manufacturers Name, and not have to deal with some association to dole out
a specific registration number. However, IPMI doesn't really have the 
detailed Sensor and Transducer fields and parameters of something like the 
<a href="https://standards.ieee.org/findstds/standard/1451.4-2004.html">TEDS</a> 
(Transducer Electronic Data Sheet) standard.   
</p>
<p>
I spent quite a bit of time reviewing the <a href="https://standards.ieee.org/findstds/standard/1451.4-2004.html">TEDS</a> 
IEEE standard, which is insanely complex enough to require it's own compiler to implement.
<a href="https://standards.ieee.org/findstds/standard/1451.4-2004.html">TEDS</a> was also designed about a decade ago,
and so many of the tradeoffs that were made in that standard, such as reduced memory footprint and reduced
packet/data sizes, are not as big a cost and performance issue as they were ten years ago.
Additionally, the default <a href="https://standards.ieee.org/findstds/standard/1451.4-2004.html">TEDS</a> interface
(which they refer to as an MMI) is based on the proprietary
<a href="https://www.maximintegrated.com/en/products/comms/one-wire.html">Dallas/Maxim 1-Wire</a> bus,
which is heavily patented (though expired perhaps?) and not really the kind of "open standard"
that I want to base our solution upon. Besides most microprocessor systems implement the
<a href="https://www.maximintegrated.com/en/products/comms/one-wire.html">Dallas/Maxim 1-Wire</a> bus
using <a href="https://en.wikipedia.org/wiki/Bit_banging">bit banging</a> on
general purpose I/O pins (GPIO), and that is really sloooow in performance.
IMHO, the <a href="https://standards.ieee.org/findstds/standard/1451.4-2004.html">TEDS</a> standard is
just too complex and convoluted for the maker community to adopt "en masse", although
it does have some pretty impressive capabilities.
</p>
<p>
One of the standards now being adopted on ARM based Linux platforms like the Beaglebone and Raspberry Pi is the
the <a href="https://www.devicetree.org/">Device Tree</a>  format.
This is a very comprehensive standard for describing the basic topology of bus connections on embedded platforms, 
and includes support for buses like ISA, PCI, SCSI, and others.
The <a href="https://www.devicetree.org/">Device Tree</a> format also requires the use of a 
compiler to turn a Device Tree Specification file into a compact binary "blob" of data, 
that bootloaders such as the <a href="https://en.wikipedia.org/wiki/GNU_GRUB">Grand Universal BootLoader</a>, or GRUB,
can parse to find the bootable devices within a embedded system. Since the embedded systems that utilize this standard typically have Megabytes
(Or Gigabytes) of memory available for decoding the binary "blob" of data that descibes the device tree,
it may not be suitable for much smaller embedded systems like the Arduino, that typically have only Kilobytes of memory available.
While it was primarily developed for describing bootable interfaces, it has been extended to support many kinds of new devices, including sensors. 
</p>
<p>
I started thinking about other, more compact ways, that could be used to implement automatic discovery
and configuration of sensors and other peripherals, using a simple metadata repository
that could be included on small form factor boards like shields and breakout boards.
This is already done using the <a href="https://www.intel.com/content/www/us/en/servers/ipmi/information-storage-definition-rev-1-2.html">IPMI FRU</a>
standard on most high-end FPGA mezzanine boards, and using the <a href="https://www.devicetree.org/">Device Tree</a> format on the new Beaglebone Black platform. 
By just including a low cost (~$.10) <a href="https://playground.arduino.cc/Code/I2CEEPROM">I2C EEPROM</a> on each shield or breakout board
to contain a device descriptor, these small form factor boards can now be automatically discovered and configured.
It would be a very small additional cost, that would greatly increase the ease of use.
(not to mention reducing those customer support calls...) 
</p>
<p>
Unfortunately, none of the standards that I have looked at have ALL of the capabilities that I'd like to see (yet),
and I don't think that I've overlooked any other options. Please give me a shout if you know of one that I may have missed...
</p>
<p>
I'm pretty familiar with the IPMI FRU standard, and it does have some Sensor support capabilities,
which they refer to as a "Sensor Data Repository", or SDR. One advantage of going with this
FRU metadata format is that there are already parsers available for Linux. If IPMI is installed on your Linux machine,
you can just use the <a href="https://manpages.ubuntu.com/manpages/precise/man8/ipmi-sensors.8.html">ipmi-sensors</a> 
command to display all the sensors running on your machine. This would work really well with 
<a href="https://www.raspians.com/Knowledgebase/2prototyping-plates-and-project-kits-for-the-pi/">Raspberry Pi Plates</a>
for example, as this Linux utility could be ported to the RaspPi pretty easily.
</p>
<p>
In my next article, I'll outline some of the tradeoffs and implications of current methods 
for automatic discovery and configuration of peripherals and sensors.
</p>
</div>
      <footer>
        <a rel="full-article" href="/news/2015/01/22/SFF-SelfConfig.html"></a>
      </footer>
    </article>
  
    
    <article>
      <header>
        <h1 class="entry-title"><a href="/news/2013/12/24/minnow-board-lures.html">MinnowBoard Lures Library</a></h1>
        
          <p class="meta">
            December 24, 2013
          </p>
        
      </header>
      <div class="entry-content">
      
      
      

<blockquote>
	<p>Give a man a fish and he has food for a day; teach him how to fish and you can get rid of him for the entire weekend.</p>
	<p>&mdash;Zenna Schaffer</p>
</blockquote>

    <p>
PatternAgents has just released a new library of MinnowBoard Lures (expansion board patterns) for the
<a href="https://www.minnowboard.org/">MinnowBoard</a> project. The library includes Type A, B, and C Lures,
with both single board patterns and "stackthru" patterns, which allow multiple Lures to be stacked up on top
of each other. If you are thinking about designing your own set of Lures, then this is the place to start.
</p>
<!-- more -->
<p>
  We've been interested in high performance small form factor platforms for a while now, especially those that can run Linux.
  The <a href="https://www.minnowboard.org/">MinnowBoard</a> is very high performance single board computer (SBC) using a 1Ghz Intel Atom processor, but unlike most SBC's it has the General Purpose I/O (GPIO) expansion connections needed to expand the system using low cost peripherals. 
  The <a href="https://www.minnowboard.org/">MinnowBoard</a> runs the <a href="https://www.angstrom-distribution.org/">Angstrom Linux Distribution</a>
  (as well as Debian) and is compatible with the <a href="https://www.yoctoproject.org/">Yocto project</a>. 
</p>
<img src="/news/minnow/minnowboard_iso.png" alt="MinnowBoard (isometric view)" title="MinnowBoard (isometric view)"/>

</div>
      <footer>
        <a rel="full-article" href="/news/2013/12/24/minnow-board-lures.html"></a>
      </footer>
    </article>
  
    
    <article>
      <header>
        <h1 class="entry-title"><a href="/news/2013/12/02/touchwidget-best-practices.html">Touch Widgets - Best Practices</a></h1>
        
          <p class="meta">
            December 02, 2013
          </p>
        
      </header>
      <div class="entry-content">
      
      
      

<blockquote>
	<p>In theory there is no difference between theory and practice. In practice there is.</p>
	<p>&mdash;Yogi Berra</p>
</blockquote>

    <p>In this post we'll discuss some of the "best practices" for implementing capacitance sensing widgets 
and control surfaces on your printed circuit boards. We've done a mash-up of several tasty tracks from different
vendors and technologies to give you a mastered mix-down...</p>
<!-- more -->
<p>You've got questions:
<ul>
	<li>How big do my Touch Widgets need to be?
	<li>How thick of a covering Overlay can I use?
    <li>How do I account for Manufacturing Variations?
	<li>How close together can I place my sensor Widgets?
	<li>How do I characterize the Signal to Noise Ratio (SNR)?
	<li>Will it blend?
</ul>
In the past few years we have answered many questions about Capacitance Sensing from our customers,
and have developed patterns of best practices to insure that their implementations are successful.
Fortunately for you, much of that work is already baked into the 
<a href="/news/2013/11/24/eagle-touch-widgets-library.html" title="Eagle Touch Widgets Library">Touch Widgets Library for Eagle</a>
that we just released, but there are several other application specific implementation issues to consider.
</p>
<h3>Touch Widget Design</h3>
<p>
In the <a href="/news/2013/11/24/eagle-touch-widgets-library.html" title="Eagle Touch Widgets Library">Touch Widgets Library for Eagle</a>
post we covered the Anatomy of a Capacitive Sensing Touch Widget, and much of what went into the construction of the Widgets themselves;
but here are a few notes on issues that you may not have noticed :
<ul>
	<li>Connection Pads are placed on the edge of the Widget (not the center) to reduce trace routing lengths,
	to minimize the parasitic capacitance (Cp) of the Widget and increase the Signal to Noise Ratio (SNR).
	<li>The Top Restrict (tRestrict) and Via Restrict (vRestrict) layers are spaced to keep other signals
	a suitable (+1.0mm) distace away from the Widget. In particular, make sure to keep any high-frequency
	clocks or other signals away from the Widget as much as possible to increase your SNR and
	reduce any false triggering.
	<li>The parasitic capacitance (Cp) of the Widget (as measured from the Widget to the surrounding ground hatch pour)
	tends to level out after about 1.0mm of spacing, however the SNR of surrounding ganged sensors (for sliders and radials)
	will start to drop off if the ganged sensors are too far apart. For that reason we have made 1.0mm (~40.0Mils) 
	as our standard spacing between ganged sensors. If you use our individual elements (i.e. single slider element) 
	to build up your own ganged sensor, you will need to factor that into your placement.
	<li>You'll notice that we used rounded corners on our Widget designs, both to reduce radiated emmissions and
	to avoid SNR spikes on the (sharp) corners of the Widgets. Squares are not your friends (neither are triangles);
	be cool, what goes 'round comes 'round, and that best for your designs.
	<li>We've provided 8mm, 10mm, and 12mm Widgets, which are generally good for plastic overlays that are &lt;4.0mm thick.
	However the dialectric constant of the material used does make a difference, so we'll show a table of those later on.
	<li>In general, you should leave &gt;1.0mm of empty space between all sides of Widget, with an Isolate of 12Mils.
	<li>Some controllers require a resistor in series with the Widget, place the resistor close to the Controller, 
	not the Widget. If using a Widget with an LED underneath, place the LED current limiting resistor close the Controller,
	not the Widget.
	<li>Best practice is to keep the Widget trace on the Bottom (back) side of the PCB, with a minimum of vias 
	before connecting to the Controller. If possible, place the Controller on the Bottom (back) side of the PCB.
	If you must place the Controller on the Top side, equalize all the trace lengths and number of vias for all
	sensors, especially for ganged sensors like sliders.
	<li>Minimize all layout traces, make them as short (and equalized) as possible, &lt;100mm is a good metric.
	If you must have long traces consider using the larger Touch Widgets (12mm), and use a thinner (&lt;2.0mm) Overlay.
	<li>Long Traces with Small Widgets and Thick Overlay = #CapSense #Fail
</ul>
</p>
<h3>Compilation of Touch Widget Best Practices</h3>
<p>
This is a compilation/distillation of best practices for our 
<a href="/news/2013/11/24/eagle-touch-widgets-library.html" title="Eagle Touch Widgets Library">Touch Widgets Library for Eagle</a>
</p>
<table border=2>
<tr>
	<th>Item</th>
	<th>Min</th>
	<th>Typ</th>
	<th>Max</th>
	<th>Notes</th>
</tr>
<tr>
	<td>Round Widget Size</td>
	<td>8 Mils</td>
	<td>10 Mils</td>
	<td>20 Mils</td>
	<td>Larger diameter increases your SNR</td>
</tr>
<tr>
	<td>Widget-to-Widget Spacing</td>
	<td>1 mm</td>
	<td>1 mm</td>
	<td>8 mm</td>
	<td>Larger if Ground Pour Isolate &gt;12 Mills</td>
</tr>
<tr>
	<td>Sawtooth Widget Size</td>
	<td>1.6 mm</td>
	<td>2 mm</td>
	<td>5 mm</td>
	<td>Make sure to round the edges on the sawteeth</td>
</tr>
<tr>
	<td>Sawtooth Widget Spacing</td>
	<td>0.6 mm</td>
	<td>2 mm</td>
	<td>5 mm</td>
	<td>Note 1 - Overlay thickness effects this</td>
</tr>
<tr>
	<td>PCB Thickness</td>
	<td>0.5 mm</td>
	<td>1.6 mm</td>
	<td>2.5 mm</td>
	<td>for FR4 material</td>
</tr>
<tr>
	<td>PCB Via Hole Size</td>
	<td>10 Mils</td>
	<td>14 Mils</td>
	<td>26 Mils</td>
	<td>Our library default is 14 Mils</td>
</tr>
<tr>
	<td>Trace Via Count</td>
	<td>1</td>
	<td>1</td>
	<td>2</td>
	<td>minimize Vias where possible</td>
</tr>
<tr>
	<td>PCB Trace Width</td>
	<td>7 Mils</td>
	<td>7 Mils</td>
	<td>20 Mils</td>
	<td>7 Mil trace/space is pretty typical, we often relax to 10 Mils for higher yields</td>
</tr>
<tr>
	<td>PCB Layer Stackup</td>
	<td>1</td>
	<td>2</td>
	<td>4</td>
	<td>Widget, Traces, Ground, Traces</td>
</tr>
<tr>
	<td>Top Ground Pour Spacing</td>
	<td>30 Mils</td>
	<td>45 Mils</td>
	<td>60 Mils</td>
	<td>7/10 Mil trace, 45 Mil Space, 12 Mil Isolate, Hatched</td>
</tr>
<tr>
	<td>Bottom Ground Pour Spacing</td>
	<td>55 Mils</td>
	<td>70 Mils</td>
	<td>90 Mils</td>
	<td>7/10 Mil trace, 70 Mil Space, 12 Mil Isolate, Hatched</td>
</tr>
<tr>
	<td>Widget to Top Pour Spacing</td>
	<td>0.5 mm</td>
	<td>1 mm</td>
	<td>4 mm</td>
	<td>Note 1 - Overlay thickness effects this</td>
</tr>
<tr>
	<td>Overlay Thickness</td>
	<td>0 mm</td>
	<td>1 mm</td>
	<td>4 mm</td>
	<td>typically 1-2 mm, plastic, glass, kapton</td>
</tr>
<tr>
	<td>Overlay Adhesive Thickness</td>
	<td>0 mm< /td>
	<td>0.1 mm </td>
	<td>0.4 mm</td>
	<td>additive with overlay thickness, use 3M/467/468MP</td>
</tr>
</table>

</div>
      <footer>
        <a rel="full-article" href="/news/2013/12/02/touchwidget-best-practices.html"></a>
      </footer>
    </article>
  
    
    <article>
      <header>
        <h1 class="entry-title"><a href="/news/2013/11/29/touch-widgets-howto.html">Touch Widgets How-To/Instructions</a></h1>
        
          <p class="meta">
            November 29, 2013
          </p>
        
      </header>
      <div class="entry-content">
      
      
      

<blockquote>
	<p>I think that things happen individually first, and then collectively. It's not the other way around.</p>
	<p>&mdash;Neale Donald Walsch</p>
</blockquote>

    <p>Pattern&#8203;Agents has been developing open source parts libraries for the Eagle CAD package, 
and we have now developed a library of Capacitive Touch Widgets to
provide a number of different control surfaces for your projects.
This How-To will cover instructions for using them in your own projects.
</p>
<!-- more -->
<p>A number of our customers have complained to us how difficult it is
to obtain or create good quality Capacitive Touch Widgets in Eagle, 
so we have spent the past week creating a new library to solve that problem.
The PatternAgents Touch Widgets Library makes Capacitive Touch technology 
available to even the most novice Eagle users.
</p>
<p>
If you have never used Eagle before, there are several starting tutorials available
on the web, such as <a href="https://www.youtube.com/watch?v=1AXwjZoyNno">this one from Jeremy Blum</a>.
This How-To assumes that you already have a basic operating knowledge of Eagle, and that
can you select a component from a library of parts, and place it in your schematic and layout.
</p>
<h3>Get the Libraries</h3>
<p>
The first step is to get the <a href="/PCB_Libraries">PatternAgents Eagle CAD Libraries from our Github Repo</a>
and install them into your Eagle package. You can either copy them into the default library location, which is usually located
at "C:\Program Files\EAGLE-6.5.0\lbr", or you can place them anywhere you prefer and add that path to the Eagle Control Panel
using "Options -> Directories -> Libraries". Personally I prefer to add the local copy of my Github Repo using the control
panel, so that whenever I do a "Github Pull", I get the most recent copies of everything directly from Github.
</p>
      <img src="/news/caps/eagle_options_directories.png" alt="eagle->options-> directories" title="eagle->options-> directories"/>
<p>
Once you have downloaded, installed, and configured the <a href="/news/2013/11/24/eagle-touch-widgets-library.html" title="Eagle Touch Widgets Library">Touch Widgets Library for Eagle</a>, go ahead and open the library tab to see all the components in the library (Version 1.0 shown) :
</p>
      <img src="/news/caps/eagle_touchwidgets_lib.png" alt="PatternAgents Touch Widgets Library" title="PatternAgents Touch Widgets Library"/>
<p>
You will see that there are a number of different widgets contained in the library, buttons, buttons with backside LED's,
linear sliders, radial sliders, and matrix (X/Y) touch pads of various sizes. The sizes are chosen according to recommended
best practices and various manufacturers design rules. We are also working on several new widgets to include in Version 2.0 of this
library; so if you have any suggestions or requests, please make sure to leave a comment or tweet to us to let us know.
Make sure to right click in the Eagle Control Panel window and select "use" for the PatternAgents-TouchWidgets and PatternAgents-Boards libraries.
</p>
<p>
In this how-to example, we are going to make a small Arduino Form Factor board that includes several different touch widgets,
and will be compatible with a number of different Arduino boards, such as the <a href="https://www.cypress.com/?rID=77780">Pioneer</a> board.
We will use the Arduino pins A0 as a select button, and A1-A5 pins for a five (5) button linear slider. 
This is a simple (arbitrary) example, but will serve to explain all the steps necessary for you to make your own designs.
</p>
<h3>Create the Schematic File</h3>
<p>
First, we are going to open a new schematic and place the PA_LEO_PATTERN from the PatternAgents-Boards library.
This pattern will give you a board outline, connectors, holes, and silkscreen that is compatible with the 
<a href="https://arduino.cc/en/Main/arduinoBoardLeonardo">Arduino Leonardo</a> form factor. This an example of
what how our design patterns work, we create reusable design patterns that you can adapt to your own purposes.
Next place, BUTTON_PASSIVE_10MM and SLIDER_PASSIVE_5SEGREV from the PatternAgents-TouchWidgets library,
and wire them up as show below :
</p>
      <img src="/news/caps/eagle_touch_howto_sch.png" alt="Eagle Touch How-To Schematic" title="Eagle Touch How-To Schematic"/>

</div>
      <footer>
        <a rel="full-article" href="/news/2013/11/29/touch-widgets-howto.html"></a>
      </footer>
    </article>
  
    
    <article>
      <header>
        <h1 class="entry-title"><a href="/news/2013/11/24/eagle-touch-widgets-library.html">Touch Widgets Library for Eagle</a></h1>
        
          <p class="meta">
            November 24, 2013
          </p>
        
      </header>
      <div class="entry-content">
      
      
      

<blockquote>
	<p>You feel touched and honored and alive when you give to someone.</p>
	<p>&mdash;Daphne Zuniga (Princess Vespa)</p>
</blockquote>

    <p>
The PatternAgents Touch Widgets Library for Eagle is a schematic and layout library
that provides the symbols and layouts for commonly used capacitive sensing control surface widgets,
such as Buttons, Linear Sliders, Radial Sliders, X-Y Touchpads and more. 
</p>
<!-- more -->
<p>PatternAgents has been developing professional grade parts libraries for Eagle, 
and we have now included a library of Capacitive Touch Widgets to
provide a number of different control surfaces for your projects.
The PatternAgents EagleCAD Libraries are schematic and PCB layout libraries 
for various electronic components that you can use with the Eagle CAD program.
</p>

</div>
      <footer>
        <a rel="full-article" href="/news/2013/11/24/eagle-touch-widgets-library.html"></a>
      </footer>
    </article>
  
    
    <article>
      <header>
        <h1 class="entry-title"><a href="/news/2013/11/20/capacitive-sensing-introduction.html">Capacitance Sensing Introduction</a></h1>
        
          <p class="meta">
            November 20, 2013
          </p>
        
      </header>
      <div class="entry-content">
      
      
      

<blockquote>
	<p>When we are touched by something it's as if we're being brushed by an angel's wings.</p>
	<p>&mdash;Rita Dove</p>
</blockquote>

    <p>Capacitive Sensing is ubiquitous now, from your smartphone screen, 
or your Apple iPod, to the "buttons" on your new TV remote control.
Today we'll be talking about how capacitive sensing works and how you can use it on your next project.</p>
<!-- more -->
<p><a href="https://en.wikipedia.org/wiki/Capacitive_sensing">Capacitive Sensing</a> is a technology that uses the human body capacitance as a sensor input to a control interface.
If you have used almost any recent smartphone touch screen or a non-mechanical button, 
then you have likely used a capacitive sensor of some kind.
There are many different applications for capacitive sensors, such as distance or proximity measurement, 
material thickness measurement, fluid level measurement, gyroscopic position, and acceleration measurement. 
Often the trackpad on your laptop is implemented an X/Y capacitance measurement device.
</p>
<p>
A <a href="https://en.wikipedia.org/wiki/Capacitor">Capacitor</a> is formed whenever two conductive surfaces are separated by an insulating layer, 
which is known as the <a href="https://en.wikipedia.org/wiki/Dielectric">dielectric</a> layer.
Capacitance is measured in  <a href="https://en.wikipedia.org/wiki/Farads">Farads</a>.
There are many different <a href="https://en.wikipedia.org/wiki/Capacitive_sensing">capacitive sensing</a> algorithms, 
and the sensors themselves can be constructed from many different materials, such as aluminum, silver, gold, copper, 
<a href="https://en.wikipedia.org/wiki/Indium_tin_oxide">Indium Tin Oxide (ITO)</a>, and various printed (conductive) inks. 
Typically copper capacitive sensors can be implemented using standard FR4 (fiberglass) 
printed circuit board material itself as the dielectric layer. 
Touch screen capacitive sensors typically utilize <a href="https://en.wikipedia.org/wiki/Indium_tin_oxide">Indium Tin Oxide (ITO)</a> materials because it can be up to ninety percent (90%) transparent, allowing you to see the screen underneath without too much light loss. 
All capacitive sensing systems work by measuring a change in capacitance as a human interacts with the sensor, and they differ
in the method, or algorithm used to measure that capacitance. 
</p>

</div>
      <footer>
        <a rel="full-article" href="/news/2013/11/20/capacitive-sensing-introduction.html"></a>
      </footer>
    </article>
  
    
    <article>
      <header>
        <h1 class="entry-title"><a href="/news/2013/11/14/building-your-new-widget.html">Building Your New Widget</a></h1>
        
          <p class="meta">
            November 14, 2013
          </p>
        
      </header>
      <div class="entry-content">
      
      
      

<blockquote>
	<p>When I write, I disturb. When I show a film, I disturb. When I exhibit my painting, I disturb, and I disturb if I don't. I have a knack for disturbing.</p>
	<p>&mdash;Jean Cocteau</p>
</blockquote>

    <p>It is a wonderful time for makers, we have terrific resources for getting things built now, with new resources appearing every day.
   Today we're going to talk about a few of the resources available to you, no matter where you live (almost).
</p>
<!-- more -->
<p>We continue to be amazed at the creativity of the maker space, and the myriad of new designs and widgets available.
Creative designers like <a href="https://dangerousprototypes.com/">Dangerous Prototypes</a>,  
and <a href="https://www.evilmadscientist.com/">Evil Mad Scientist</a>, to name just a few, 
are releasing dozens of new open sourced hardware designs every year. <br> 
As we travel and meet other people in the maker community, <br>
we often get asked the same question : <br> 
<b>"So how do get your stuff made, where can we get our things built?"</b>
<br>
And usually what they are asking about are small quantities of things, <br>
often the first prototypes of a new widget or design.</p>

</div>
      <footer>
        <a rel="full-article" href="/news/2013/11/14/building-your-new-widget.html"></a>
      </footer>
    </article>
  
    
    <article>
      <header>
        <h1 class="entry-title"><a href="/news/2013/11/11/eaglecad-libraries.html">EagleCAD Libraries</a></h1>
        
          <p class="meta">
            November 11, 2013
          </p>
        
      </header>
      <div class="entry-content">
      
      
      

<blockquote>
	<p>A library is the delivery room for the birth of ideas, a place where history comes to life.</p>
	<p>&mdash;Norman Cousins</p>
</blockquote>

    <p>We have several man-years of effort invested in developing professional grade parts libraries for Eagle, 
and now we've made them available to you, our user community, on our Github Repo.
The PatternAgents EagleCAD Libraries are schematic and PCB layout libraries 
for various electronic components and systems for use within the Eagle CAD program.</p>
<!-- more -->

</div>
      <footer>
        <a rel="full-article" href="/news/2013/11/11/eaglecad-libraries.html"></a>
      </footer>
    </article>
  
    
    <article>
      <header>
        <h1 class="entry-title"><a href="/news/2013/11/09/quattrocycle-update.html">Quattrocycle Lighting Update</a></h1>
        
          <p class="meta">
            November 09, 2013
          </p>
        
      </header>
      <div class="entry-content">
      
      
      

<blockquote>
	<p>Life is like riding a bicycle. To keep your balance you must keep moving.</p>
	<p>&mdash;Albert Einstein</p>
</blockquote>

    	<p>
	This week we've been working on a custom lighting System for the Quattrocycle,
	a four wheeled, family quad-cycle with independent gearing and suspension.
	</p>
    <!-- more -->
	<p>
      <img src="https://www.chatnbike.com/WebObjects/FamilyCycleGroupOrder.woa/Contents/WebServerResources/images/cycles/quattro13.jpg" width="400" border="0" alt="Quattrocycle">
    </p>
  <p>
   The BridgerSoc Lighting System is on it's way to good folks at <a href="https://www.chatnbike.com/">Chat 'n Bike</a> 
   and we can't wait to see what it looks like once it is installed on one of the Quattrocycles!
  </p>

</div>
      <footer>
        <a rel="full-article" href="/news/2013/11/09/quattrocycle-update.html"></a>
      </footer>
    </article>
  
    
    <article>
      <header>
        <h1 class="entry-title"><a href="/news/2013/09/13/portland-maker-faire.html">Portland Mini-Maker Faire</a></h1>
        
          <p class="meta">
            September 13, 2013
          </p>
        
      </header>
      <div class="entry-content">
      
      
      

<blockquote>
	<p>Write it. Shoot it. Publish it. Crochet it, Saute it, whatever. MAKE.</p>
	<p>&mdash;Josh Whedon</p>
</blockquote>

      <p>
   Thank You to everyone who stopped in at Booth 18 and said hello! 
   We were very pleased that we had visitors from Canada to Mexico stop in,
   as well as many old and new friends from all over the Portland/Vancouver area. 
  </p>
<!-- more -->
  <p>
  The kids really liked the LED lighting and motor control demonstrations we were doing,
  and a lot of the kids asked interesting questions about how the circuits worked and what they did.
  It was a lot of fun, and our very first time at a Maker Faire. Fortunately the weather held,
  and we only had a few sprinkles of rain on Sunday morning, and the weather cleared up in the morning.
  We'll have to try to make it down to the big Maker Faire in San Francisco next year...
  </p>
  <div class="container">
  	  <iframe width="640" height="390" src="//www.youtube.com/embed/8rQDTiCeZTw?HD=1;rel=0;showinfo=0;controls=0" frameborder="0" allowfullscreen></iframe>
  </div></div>
      <footer>
        <a rel="full-article" href="/news/2013/09/13/portland-maker-faire.html"></a>
      </footer>
    </article>
  
    
    <article>
      <header>
        <h1 class="entry-title"><a href="/news/2013/07/09/arduino-yun-the-next-generation.html">Arduino Y'un - The Next Generation</a></h1>
        
          <p class="meta">
            July 09, 2013
          </p>
        
      </header>
      <div class="entry-content">
      
      
      

<blockquote>
	<p>Clouds come floating into my life, no longer to carry rain or usher storm, but to add color to my sunset sky...</p>
	<p>&mdash;Rabindranath Tagore</p>
</blockquote>

    <p>
  Y'un means &ldquo;Cloud&rdquo; in Chinese, and the latest small form factor board from Arduino is clearly intended for &ldquo;cloud applications&rdquo;,
  and enabling the &ldquo;Internet of Things&rdquo;. The Y'un includes an Atheros/Qualcomm AR9331 System-on-Chip device that includes a MIPS processor
  with a Wi-Fi radio, as well as wired USB and Ethernet connections. In order to maintain backward compatibility with the Arduino IDE tools,
  it also includes a legacy ATMega324 for running standard Arduino sketches.
</p>
<!-- more -->
<p>
  <img class="illo" src="/sff/yun.png" alt="Arduino Y'un" title="Arduino Y'un"/>
</p>
<h3>What is on a Y'un?</h3>
<ul>
  <li>2.4" by 2.1" Arduino/Leonardo Form Factor</li>
  <li>Atheros/Qualcomm AR9331 SOC</li>
  <li>400Mhz MIPS 24K CPU</li>
  <li>Atmel ATMega324 Processor</li>
  <li>(14) GPIO</li>
  <li>micro-USB</li>
  <li>USB-A</li>
  <li>RJ45 Ethernet</li>
  <li>micro-SD Memory Card Slot</li>
  <li>Linino Embedded Linux</li>
</ul>

</div>
      <footer>
        <a rel="full-article" href="/news/2013/07/09/arduino-yun-the-next-generation.html"></a>
      </footer>
    </article>
  
    
    <article>
      <header>
        <h1 class="entry-title"><a href="/news/2013/07/08/minnow-board-small-form-factor.html">The Minnow Board - A New Small Form Factor</a></h1>
        
          <p class="meta">
            July 08, 2013
          </p>
        
      </header>
      <div class="entry-content">
      
      
      

<blockquote>
	<p>Many men go fishing all of their lives without knowing that it is not fish they are after...</p>
	<p>&mdash;Henry David Thoreau</p>
</blockquote>

    <p>
  We attended an "Internet of Things" meeting here this week, and Scott Garman introduced us to a new small form factor, the <a href="https://www.minnowboard.org/">MinnowBoard</a>. The MinnowBoard is very high performance single board computer (SBC) using a 1Ghz Intel Atom processor, but unlike most SBC's it has the General Purpose I/O (GPIO) expansion connections needed to expand the system using low cost peripherals. More akin to SBC's like the Raspberry Pi, it runs the <a href="https://www.angstrom-distribution.org/">Angstrom Linux Distribution</a> and is compatible with the <a href="https://www.yoctoproject.org/">Yocto project</a>. This looks to be a very nice high-end SBC for embedded work that requires the power of an Intel CPU.
</p>
<!-- more -->
<p>
<img class="illo" src="/news/minnow/minnowboard_iso.png" alt="MinnowBoard (isometric view)" title="MinnowBoard (isometric view)"/>
</p>
<h3>What is on a MinnowBoard?</h3>
<ul>
  <li>4.2" by 4.2" Form Factor</li>
  <li>Intel Atom E640 (1GHz, 32bit)</li>
  <li>EG20T Intel Platform Controller Hub</li>
  <li>Integrated Intel Graphics Media Accelerator GMA600</li>
  <li>1 GB DDR2 RAM</li>
  <li>4 MB SPI Flash</li>
  <li>(2) USB Host I/F</li>
  <li>(1) USB Device I/F</li>
  <li>Gigabit Ethernet</li>
  <li>SATA2 3Gb/sec</li>
  <li>PCI Express</li>
  <li>(1) SDIO</li>
  <li>(4) Switches</li>
  <li>(2) LEDs</li>
  <li>(8) GPIO</li>
  <li>(2) UART</li>
  <li>(1) I2C</li>
  <li>(1) SMB</li>
  <li>(1) SPI</li>
  <li>(1) CAN-Bus</li>
  <li>"Lure" Expansion Connector</li>
  <li>UEFI Boot Loader</li>
</ul>

</div>
      <footer>
        <a rel="full-article" href="/news/2013/07/08/minnow-board-small-form-factor.html"></a>
      </footer>
    </article>
  
    
    <article>
      <header>
        <h1 class="entry-title"><a href="/news/2013/07/07/microcontroller-small-form-factors.html">Small Form Factors for Embedded Devices</a></h1>
        
          <p class="meta">
            July 07, 2013
          </p>
        
      </header>
      <div class="entry-content">
      
      
      

<blockquote>
	<p>Success is the sum of small efforts, repeated day in and day out...</p>
	<p>&mdash;Robert J. Collier</p>
</blockquote>

    <p>
  There are dozens of different <b>Small Form Factors</b> in use today.
  The largest volume of those being used in Embedded Personal Computers (PC's), such as the 
  <a href="https://en.wikipedia.org/wiki/Small_form_factor">Mini-ITX, Nano-ITX and Pico-ITX</a>
  form factors. However, what we're going to talk about today are even smaller form factors,
  typically those used for embedded microcontrollers in application specific uses, such as
  smart devices and process controllers. Today we're talking about form factors for processors,
  and in upcoming segments we'll also be covering those used for adding small peripherals and
  interfaces to other (larger) form factors.
</p>
<!-- more -->
<h3>What is a Small Form Factor? </h3>
<p>
  Small Form Factor lacks a normative definition and is consequently open to (mis)interpretation and/or misuse.
  It historically referred to any (PC) computer format that was smaller than a traditional tower computer,
  and was applied to any smaller computer, such as shoebox size (Shuttle), small cubes, net-tops and book sized computers.
</p>
<p>
 For the purposes of discussion today, we will define a Small Form Factor as,
 any computing device, or circuit board, that is smaller than the Standard ATX motherboard,
 meaning smaller than 12.00 by 9.65 inches (305mm by 244mm).
</p>
<h3>Trends in Small Form Factors for Embedded Devices</h3>
<p>
  There are two primary trends in Small Form Factor adoption today, and those break down
  along the lines of quasi-Proprietary standards versus Open Source Hardware standards.
  Companies like Texas Instruments have adopted quasi-Proprietary standards, such as the 
  <a href="https://www.ti.com/launchpad/">TI LaunchPad</a> and the 
  <a href="https://beagleboard.org/">BeagleBoard</a>, 
  which are used primarily to market and support their proprietary microprocessor/microcontroller products. 
  While other companies like Atmel, Freescale, and Cypress Semiconductor have embraced
  Open Source Hardware platforms such as the
  <a href="https://arduino.cc/">Arduino</a> family of small form factor boards. 
  The <a href="https://www.raspberrypi.org/">Raspberry Pi</a> was developed in the UK by the Raspberry Pi Foundation
  with the intention of providing a low cost platform for teaching basic computer science in schools.
  Other vendors like NXP, have embraced a more breadboard friendly Dual-Inline-Package (DIP) format,
  and have been having great success with their "mbed" format for small embedded processors.
</p>
<ul class="illo-list">
  <li>
    <span>
       <a href="https://www.ti.com/launchpad/"><img class="illo" src="/news/sff/launchpad.png" alt="TI LaunchPad" title="TI LaunchPad"/></a>
    </span>
  </li>
  <li>
    <span>
       <a href="https://beagleboard.org/"><img class="illo" src="/news/sff/beaglebone.png" alt="TI BeagleBoard" title="TI BeagleBoard"/></a>
    </span>
  </li>
</ul>

</div>
      <footer>
        <a rel="full-article" href="/news/2013/07/07/microcontroller-small-form-factors.html"></a>
      </footer>
    </article>
  


    </div>
    <div class="col maj_minor">
      
  <h2>Recent Tweets</h2>
  

<!-- twitter -->
<div class="panel">
  <a  class="twitter-timeline"
      href="" 
      data-widget-id=""
      data-tweet-limit="">
    
  </a>
</div>


    </div>
  </div>

  </div>
  <div class="col minor">
    
    
  <h2>Featured Projects</h2>
  <ul class="post-list">
  
</ul>


  </div>

</main>
   

<form id="signup"
      action="https://patternagents.us5.list-manage.com/subscribe/post?u=d606135278a28bf2e4504c9ef&id=34ecdcaa40"
      method="post"
      id="mc-embedded-subscribe-form"
      name="mc-embedded-subscribe-form"
      class="validate"
      target="_blank"
      novalidate>
  <div class="row"><div class="col">
    
  <div class="row collapse">
      <input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL" placeholder="email address" required>
      <button class="postfix" type="submit">Subscribe</button>
  </div>
  </div></div>
</form>

   <!-- Add the discussion widget -->
   

<!-- discus panel -->
<!-- place "comments: true" in the YAML front matter to enable comments in that page -->

   

<footer>
  <div class="row">
    <div class="col half">
      <div class="row">
        <div class="col quarter">
          <ul class="social-icons">
           <li><a href="https://twitter.com/PatternAgents" title="twitter"><img src="/logos/white/twitter.png"></a></li>
            <li><a href="https://github.com/PatternAgents" title="github"><img src="/logos/white/github.png"></a></li>
            <li><a href="https://www.linkedin.com/company/3092259" title="linkedin"><img src="/logos/white/linkedin.png"></a></li>
            <li><a href="https://www.facebook.com/PatternAgents/" title="facebook"><img src="/logos/white/facebook.png"></a></li>
            <li><a href="https://pinterest.com/patternagents" title="pinterest"><img src="/logos/white/pinterest.png"></a></li>
          </ul>
        </div>
        <div class="col quarter">
            <h2><a href="">Contact</a></h2>
            <ul>
              <li><a href="">Press</a></li>
              <li><a href="">Investors</a></li>
              <li><a href="">Licensing</a></li>
              <li><a href="">Credits</a></li>
            </ul>
        </div>
      </div>
    </div>
    <div class="col half">
      <div class="row">
        <div class="col quarter">
          <h2><a href="">About Us</a></h2>
          <ul>
            <li><a href="">For Manufacturers</a></li>
            <li><a href="">For Distributors</a></li>
            <li><a href="">For Representatives</a></li>
          </ul>
        </div>
        <div class="col quarter">
          <h2><a href="">Policies</a></h2>
          <ul>
            <li><a href="">We Use Cookies</a></li>
            <li><a href="">Privacy</a></li> 
            <li><a href="">Shipping</a></li>
            <li><a href="">Returns</a></li>
            <li><a href="">Legal</a></li>
          </ul>
        </div>
      </div>
    </div>
  </div>
  <div class="row unimportant">
    <div class="col quarter"><p>Copyright &copy; 2010-2019 PatternAgents</p></div>
  </div>
</footer>

<script src="/js/lib/jquery.js"></script>


<!-- disqus widget script -->
<script type="text/javascript">
  var disqus_shortname = 'patternagents';
  (function() {
   var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
   dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
   (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>



<!-- pinterest widget script -->
<script type="text/javascript">
(function(d){
  var f = d.getElementsByTagName('SCRIPT')[0], p = d.createElement('SCRIPT');
  p.type = 'text/javascript';
  p.async = true;
  p.setAttribute('data-pin-color', 'red');
  p.setAttribute('data-pin-hover', 'true');
  p.src = 'https://assets.pinterest.com/js/pinit.js';
  f.parentNode.insertBefore(p, f);
}(document));
</script>

<!-- toggle menu -->
<script>
  $(function() {
    var $navToggle = $('nav.toggle');
    $navToggle.addClass('collapsed');
    $navToggle.find('h2').bind('click focus', function() {
      // if we want to get fancy, we can animate the max-height here
      $navToggle.toggleClass('collapsed');
    });
  });
</script>




  
  
  

<!-- twitter widget script -->
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^https:/.test(d.location)?'https':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>











</body>
</html>
